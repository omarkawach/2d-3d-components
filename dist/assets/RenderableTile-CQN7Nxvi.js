import{fG as D,cU as O}from"./index-8ERthB3p.js";import{o as F,M as k,h as z,f as E}from"./mat3-CqxUQBLP.js";import{e as M}from"./DefaultUI-DIlogOoy.js";import{E as g}from"./enums-BRzLM11V.js";import"./TileStrategy-BMTAwxMt.js";import{e as W}from"./TileKey-Drwp1tmy.js";import{w as v}from"./GeometryUtils-_MjrRDxY.js";import{h as d}from"./BufferObject-CaEbWulZ.js";import{F as m}from"./enums-DSseSvdG.js";import{o as b}from"./VertexArrayObject-Cv4RwmVi.js";import{e as C}from"./config-MDUrh2eL.js";import{r as L}from"./DefaultVertexAttributeLayouts-Co_GH1pH.js";let $=class{constructor(e,r){this.sourceTile=r,this.xTile=0,this.yTile=0,this.hash=0,this.priority=1,this.featureIndex=0,this.colliders=[],this.textVertexRanges=[],this.iconVertexRanges=[],this.tile=e}};class ht{constructor(){this.tileSymbols=[],this.parts=[{startTime:0,startOpacity:0,targetOpacity:0,show:!1},{startTime:0,startOpacity:0,targetOpacity:0,show:!1}],this.show=!1}}function lt(l,e,r,t,s,i){const a=r-s;if(a>=0)return(e>>a)+(t-(i<<a))*(l>>a);const o=-a;return e-(i-(t<<o))*(l>>o)<<o}class ct{constructor(e,r,t){this._rows=Math.ceil(r/t),this._columns=Math.ceil(e/t),this._cellSize=t,this.cells=new Array(this._rows);for(let s=0;s<this._rows;s++){this.cells[s]=new Array(this._columns);for(let i=0;i<this._columns;i++)this.cells[s][i]=[]}}getCell(e,r){const t=Math.min(Math.max(Math.floor(r/this._cellSize),0),this._rows-1),s=Math.min(Math.max(Math.floor(e/this._cellSize),0),this._columns-1);return this.cells[t]&&this.cells[t][s]||null}getCellSpan(e,r,t,s){return[Math.min(Math.max(Math.floor(e/this._cellSize),0),this.columns-1),Math.min(Math.max(Math.floor(r/this._cellSize),0),this.rows-1),Math.min(Math.max(Math.floor(t/this._cellSize),0),this.columns-1),Math.min(Math.max(Math.floor(s/this._cellSize),0),this.rows-1)]}get cellSize(){return this._cellSize}get columns(){return this._columns}get rows(){return this._rows}}function Y(l,e,r,t,s,i,a){const o=e[t++];for(let h=0;h<o;h++){const n=new $(i,a);n.xTile=e[t++],n.yTile=e[t++],n.hash=e[t++],n.priority=e[t++],n.featureIndex=e[t++];const c=e[t++];for(let f=0;f<c;f++){const x=e[t++],I=e[t++],p=e[t++],A=e[t++],w=!!e[t++],_=e[t++],R=r[t++],V=r[t++],B=e[t++],P=e[t++];n.colliders.push({xTile:x,yTile:I,dxPixels:p,dyPixels:A,hard:w,partIndex:_,width:B,height:P,minLod:R,maxLod:V})}const u=l[t++];for(let f=0;f<u;f++)n.textVertexRanges.push([l[t++],l[t++]]);const y=l[t++];for(let f=0;f<y;f++)n.iconVertexRanges.push([l[t++],l[t++]]);s.push(n)}return t}function ut(l,e,r){for(const[t,s]of l.symbols)q(l,e,r,s,t)}function q(l,e,r,t,s){const i=l.layerData.get(s);if(i.type===g.SYMBOL){for(const a of t){const o=a.unique;let h;if(a.selectedForRendering){const n=o.parts[0],c=n.startOpacity,u=n.targetOpacity;l.allSymbolsFadingOut=l.allSymbolsFadingOut&&u===0;const y=r?Math.floor(127*c)|u<<7:u?255:0;h=y<<24|y<<16|y<<8|y}else h=0;for(const[n,c]of a.iconVertexRanges)for(let u=n;u<n+c;u+=4)i.iconOpacity[u/4]=h;if(a.selectedForRendering){const n=o.parts[1],c=n.startOpacity,u=n.targetOpacity;l.allSymbolsFadingOut=l.allSymbolsFadingOut&&u===0;const y=r?Math.floor(127*c)|u<<7:u?255:0;h=y<<24|y<<16|y<<8|y}else h=0;for(const[n,c]of a.textVertexRanges)for(let u=n;u<n+c;u+=4)i.textOpacity[u/4]=h}i.lastOpacityUpdate=e,i.opacityChanged=!0}}function yt(l,e,r,t){const s=l.colliders;let i,a,o,h;for(const n of s)if(l.unique.show&&l.unique.parts[n.partIndex].show&&(i=n.xScreen-t[0]+n.dxScreen,a=n.yScreen-t[1]+n.dyScreen,o=i+n.width,h=a+n.height,v(r,e.x,e.y,i,a,o,h)))return!0;return!1}class S{constructor(e,r){this.layerUIDs=[],this.isDestroyed=!1,this._data=e;let t=1;const s=new Uint32Array(e);this.layerUIDs=[];const i=s[t++];for(let a=0;a<i;a++)this.layerUIDs[a]=s[t++];this.bufferDataOffset=t,r&&(this.layer=r.getStyleLayerByUID(this.layerUIDs[0]))}get isPreparedForRendering(){return this._data==null}get offset(){return this.bufferDataOffset}get data(){return this._data}destroy(){this.isDestroyed||(this.doDestroy(),this._data=null,this.isDestroyed=!0)}prepareForRendering(e){this._data!=null&&(this.doPrepareForRendering(e,this._data,this.bufferDataOffset),this._data=null)}}class j extends S{constructor(e,r){super(e,r),this.type=g.LINE,this.lineIndexStart=0,this.lineIndexCount=0;const t=new Uint32Array(e);let s=this.bufferDataOffset;this.lineIndexStart=t[s++],this.lineIndexCount=t[s++];const i=t[s++];if(i>0){this.patternMap=new Map;for(let a=0;a<i;a++){const o=t[s++],h=t[s++],n=t[s++];this.patternMap.set(o,[h,n])}}this.bufferDataOffset=s}get memoryUsed(){var e,r;return(((e=this.data)==null?void 0:e.byteLength)??0)+(((r=this.vao)==null?void 0:r.usedMemory)??0)}hasData(){return this.lineIndexCount>0}triangleCount(){return this.lineIndexCount/3}doDestroy(){this.vao=D(this.vao)}doPrepareForRendering(e,r,t){const s=new Uint32Array(r),i=new Int32Array(s.buffer),a=s[t++],o=d.createVertex(e,m.STATIC_DRAW,new Int32Array(i.buffer,4*t,a));t+=a;const h=s[t++],n=d.createIndex(e,m.STATIC_DRAW,new Uint32Array(s.buffer,4*t,h));t+=h;const c=this.layer.lineMaterial;this.vao=new b(e,c.getAttributeLocations(),c.getLayoutInfo(),{geometry:o},n)}}class N extends S{constructor(e,r){super(e,r),this.type=g.FILL,this.fillIndexStart=0,this.fillIndexCount=0,this.outlineIndexStart=0,this.outlineIndexCount=0;const t=new Uint32Array(e);let s=this.bufferDataOffset;this.fillIndexStart=t[s++],this.fillIndexCount=t[s++],this.outlineIndexStart=t[s++],this.outlineIndexCount=t[s++];const i=t[s++];if(i>0){this.patternMap=new Map;for(let a=0;a<i;a++){const o=t[s++],h=t[s++],n=t[s++];this.patternMap.set(o,[h,n])}}this.bufferDataOffset=s}get memoryUsed(){var e,r,t;return(((e=this.data)==null?void 0:e.byteLength)??0)+(((r=this.fillVAO)==null?void 0:r.usedMemory)??0)+(((t=this.outlineVAO)==null?void 0:t.usedMemory)??0)}hasData(){return this.fillIndexCount>0||this.outlineIndexCount>0}triangleCount(){return(this.fillIndexCount+this.outlineIndexCount)/3}doDestroy(){this.fillVAO=D(this.fillVAO),this.outlineVAO=D(this.outlineVAO)}doPrepareForRendering(e,r,t){const s=new Uint32Array(r),i=new Int32Array(s.buffer),a=s[t++],o=d.createVertex(e,m.STATIC_DRAW,new Int32Array(i.buffer,4*t,a));t+=a;const h=s[t++],n=d.createIndex(e,m.STATIC_DRAW,new Uint32Array(s.buffer,4*t,h));t+=h;const c=s[t++],u=d.createVertex(e,m.STATIC_DRAW,new Int32Array(i.buffer,4*t,c));t+=c;const y=s[t++],f=d.createIndex(e,m.STATIC_DRAW,new Uint32Array(s.buffer,4*t,y));t+=y;const x=this.layer,I=x.fillMaterial,p=x.outlineMaterial;this.fillVAO=new b(e,I.getAttributeLocations(),I.getLayoutInfo(),{geometry:o},n),this.outlineVAO=new b(e,p.getAttributeLocations(),p.getLayoutInfo(),{geometry:u},f)}}class G extends S{constructor(e,r,t){super(e,r),this.type=g.SYMBOL,this.iconPerPageElementsMap=new Map,this.glyphPerPageElementsMap=new Map,this.symbolInstances=[],this.isIconSDF=!1,this.opacityChanged=!1,this.lastOpacityUpdate=0,this.symbols=[];const s=new Uint32Array(e),i=new Int32Array(e),a=new Float32Array(e);let o=this.bufferDataOffset;this.isIconSDF=!!s[o++];const h=s[o++],n=s[o++],c=s[o++],u=new W(h,n,c,0),y=s[o++];for(let p=0;p<y;p++){const A=s[o++],w=s[o++],_=s[o++];this.iconPerPageElementsMap.set(A,[w,_])}const f=s[o++];for(let p=0;p<f;p++){const A=s[o++],w=s[o++],_=s[o++];this.glyphPerPageElementsMap.set(A,[w,_])}const x=s[o++],I=s[o++];this.iconOpacity=new Int32Array(x),this.textOpacity=new Int32Array(I),o=Y(s,i,a,o,this.symbols,t,u),this.bufferDataOffset=o}get memoryUsed(){var e,r,t;return(((e=this.data)==null?void 0:e.byteLength)??0)+(((r=this.iconVAO)==null?void 0:r.usedMemory)??0)+(((t=this.textVAO)==null?void 0:t.usedMemory)??0)+O(this.iconOpacity)+O(this.textOpacity)}hasData(){return this.iconPerPageElementsMap.size>0||this.glyphPerPageElementsMap.size>0}triangleCount(){let e=0;for(const[r,t]of this.iconPerPageElementsMap)e+=t[1];for(const[r,t]of this.glyphPerPageElementsMap)e+=t[1];return e/3}doDestroy(){this.iconVAO=D(this.iconVAO),this.textVAO=D(this.textVAO)}updateOpacityInfo(){if(!this.opacityChanged)return;this.opacityChanged=!1;const e=this.iconOpacity,r=this.iconVAO.vertexBuffers.opacity;e.length>0&&e.byteLength===r.usedMemory&&r.setSubData(e,0,0,e.length);const t=this.textOpacity,s=this.textVAO.vertexBuffers.opacity;t.length>0&&t.byteLength===s.usedMemory&&s.setSubData(t,0,0,t.length)}doPrepareForRendering(e,r,t){const s=new Uint32Array(r),i=new Int32Array(s.buffer),a=s[t++],o=d.createVertex(e,m.STATIC_DRAW,new Int32Array(i.buffer,4*t,a));t+=a;const h=s[t++],n=d.createIndex(e,m.STATIC_DRAW,new Uint32Array(s.buffer,4*t,h));t+=h;const c=s[t++],u=d.createVertex(e,m.STATIC_DRAW,new Int32Array(i.buffer,4*t,c));t+=c;const y=s[t++],f=d.createIndex(e,m.STATIC_DRAW,new Uint32Array(s.buffer,4*t,y));t+=y;const x=d.createVertex(e,m.STATIC_DRAW,this.iconOpacity.buffer),I=d.createVertex(e,m.STATIC_DRAW,this.textOpacity.buffer),p=this.layer,A=p.iconMaterial,w=p.textMaterial;this.iconVAO=new b(e,A.getAttributeLocations(),A.getLayoutInfo(),{geometry:o,opacity:x},n),this.textVAO=new b(e,w.getAttributeLocations(),w.getLayoutInfo(),{geometry:u,opacity:I},f)}}let H=class extends S{constructor(e,r){super(e,r),this.type=g.CIRCLE,this.circleIndexStart=0,this.circleIndexCount=0;const t=new Uint32Array(e);let s=this.bufferDataOffset;this.circleIndexStart=t[s++],this.circleIndexCount=t[s++],this.bufferDataOffset=s}get memoryUsed(){var e,r;return(((e=this.data)==null?void 0:e.byteLength)??0)+(((r=this.vao)==null?void 0:r.usedMemory)??0)}hasData(){return this.circleIndexCount>0}triangleCount(){return this.circleIndexCount/3}doDestroy(){this.vao=D(this.vao)}doPrepareForRendering(e,r,t){const s=new Uint32Array(r),i=new Int32Array(s.buffer),a=s[t++],o=d.createVertex(e,m.STATIC_DRAW,new Int32Array(i.buffer,4*t,a));t+=a;const h=s[t++],n=d.createIndex(e,m.STATIC_DRAW,new Uint32Array(s.buffer,4*t,h));t+=h;const c=this.layer.circleMaterial;this.vao=new b(e,c.getAttributeLocations(),c.getLayoutInfo(),{geometry:o},n)}};class T extends L{constructor(e,r,t,s,i,a,o,h=null){super(e,r,t,s,i,a,4096,4096),this.styleRepository=o,this._memCache=h,this.type="vector-tile",this._referenced=0,this._hasSymbolBuckets=!1,this._memoryUsedByLayerData=0,this.layerData=new Map,this.status="loading",this.allSymbolsFadingOut=!1,this.lastOpacityUpdate=0,this.symbols=new Map,this.isCoverage=!1,this.neededForCoverage=!1,this.decluttered=!1,this.parentTile=null,this.childrenTiles=new Set,this.featureIndex=null,this.triangleCount=0,this._processed=!1,this._referenced=1,this.id=e.id}get hasSymbolBuckets(){return this._hasSymbolBuckets}get isFading(){return this._hasSymbolBuckets&&performance.now()-this.lastOpacityUpdate<C}get isHoldingForFade(){return this._hasSymbolBuckets&&(!this.allSymbolsFadingOut||performance.now()-this.lastOpacityUpdate<C)}get wasRequested(){return this.status==="errored"||this.status==="loaded"||this.status==="reloading"}setData(e){this.changeDataImpl(e),this.requestRender(),this.ready(),this._processed=!0}deleteLayerData(e){var t,s;let r=!1;for(const i of e){const a=this.layerData.get(i);a&&(this._memoryUsedByLayerData-=a.memoryUsed,a.type===g.SYMBOL&&this.symbols.delete(i)&&(r=!0),a.destroy(),this.layerData.delete(i))}(t=this._memCache)==null||t.updateSize(this.key.id,this,this._memoryUsedByLayerData),r&&((s=this.featureIndex)==null||s.clear(),this.emit("symbols-changed")),this.requestRender()}processed(){return this._processed}hasData(){return this.layerData.size>0}dispose(){this.status!=="unloaded"&&(this.featureIndex=null,U.delete(this),T._destroyRenderBuckets(this.layerData),this.layerData.clear(),this._memoryUsedByLayerData=0,this.destroy(),this.status="unloaded")}release(){return--this._referenced==0&&(this.dispose(),this.stage=null,!0)}retain(){++this._referenced}get referenced(){return this._referenced}get usedMemory(){return this._memoryUsedByLayerData+256}changeDataImpl(e){var t,s;(t=this.featureIndex)==null||t.clear();let r=!1;if(e){const{bucketsWithData:i,emptyBuckets:a}=e,o=this._createRenderBuckets(i);if(a&&a.byteLength>0){const h=new Uint32Array(a);for(const n of h)this._deleteLayerData(n)}for(const[h,n]of o)this._deleteLayerData(h),n.type===g.SYMBOL&&(this.symbols.set(h,n.symbols),r=!0),this._memoryUsedByLayerData+=n.memoryUsed,this.layerData.set(h,n);(s=this._memCache)==null||s.updateSize(this.key.id,this,this.usedMemory)}this._hasSymbolBuckets=!1;for(const[i,a]of this.layerData)a.type===g.SYMBOL&&(this._hasSymbolBuckets=!0);r&&this.emit("symbols-changed")}attachWithContext(e){this.stage={context:e,trashDisplayObject(r){r.processDetach()},untrashDisplayObject:()=>!1}}setTransform(e){super.setTransform(e);const r=this.resolution/(e.resolution*e.pixelRatio),t=this.width/this.rangeX*r,s=this.height/this.rangeY*r,i=[0,0];e.toScreen(i,[this.x,this.y]);const a=this.transforms.tileUnitsToPixels;F(a),k(a,a,i),z(a,a,Math.PI*e.rotation/180),E(a,a,[t,s,1])}_createTransforms(){return{displayViewScreenMat3:M(),tileMat3:M(),tileUnitsToPixels:M()}}static _destroyRenderBuckets(e){if(!e)return;const r=new Set;for(const t of e.values())r.has(t)||(t.destroy(),r.add(t));e.clear()}_createRenderBuckets(e){const r=new Map,t=new Map;for(const s of e){const i=this._deserializeBucket(s,t);for(const a of i.layerUIDs)r.set(a,i)}return r}_deserializeBucket(e,r){let t=r.get(e);if(t)return t;switch(new Uint32Array(e)[0]){case g.FILL:t=new N(e,this.styleRepository);break;case g.LINE:t=new j(e,this.styleRepository);break;case g.SYMBOL:t=new G(e,this.styleRepository,this);break;case g.CIRCLE:t=new H(e,this.styleRepository)}return r.set(e,t),t}_deleteLayerData(e){if(!this.layerData.has(e))return;const r=this.layerData.get(e);this._memoryUsedByLayerData-=r.memoryUsed,r.destroy(),this.layerData.delete(e)}}const U=new Map;function dt(){U.forEach((l,e)=>{console.log(`
${e.key}:`),l[0].forEach(r=>console.log(r)),console.log("========"),l[1].forEach(r=>console.log(r))})}class mt extends L{_createTransforms(){return{displayViewScreenMat3:M(),tileMat3:M()}}}export{yt as c,T as d,ct as i,lt as o,ut as r,ht as s,mt as t,dt as u};
