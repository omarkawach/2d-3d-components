import{aT as T,c$ as X,dg as K,bW as Q,c5 as Z,bR as ee,mH as H,mI as k,dE as j}from"./index-8ERthB3p.js";import{n as te,o as S}from"./interfaces-B8ge7Jg9.js";import{a as V}from"./basicInterfaces-DngWxyLO.js";import{s as re,u as se,j as U,f as ie,h as oe,v as ce}from"./Texture-C7A05GrI.js";import{e as _}from"./VertexAttribute-BnAa5VW0.js";import{x as G,c as D,y as ae,u as ne,q as le,i as M}from"./BufferView-CHYzaV9A.js";import{s as z}from"./Util-B8vYs4k8.js";let Te=class extends re{constructor(t){super(t),this._numLoading=0,this._disposed=!1,this._textureRepository=t.textureRepository,this._textureId=t.textureId,this._acquire(t.textureId,r=>this._texture=r),this._acquire(t.normalTextureId,r=>this._textureNormal=r),this._acquire(t.emissiveTextureId,r=>this._textureEmissive=r),this._acquire(t.occlusionTextureId,r=>this._textureOcclusion=r),this._acquire(t.metallicRoughnessTextureId,r=>this._textureMetallicRoughness=r)}dispose(){this._texture=T(this._texture),this._textureNormal=T(this._textureNormal),this._textureEmissive=T(this._textureEmissive),this._textureOcclusion=T(this._textureOcclusion),this._textureMetallicRoughness=T(this._textureMetallicRoughness),this._disposed=!0}ensureResources(t){return this._numLoading===0?V.LOADED:V.LOADING}get textureBindParameters(){return new ue(this._texture!=null?this._texture.glTexture:null,this._textureNormal!=null?this._textureNormal.glTexture:null,this._textureEmissive!=null?this._textureEmissive.glTexture:null,this._textureOcclusion!=null?this._textureOcclusion.glTexture:null,this._textureMetallicRoughness!=null?this._textureMetallicRoughness.glTexture:null)}updateTexture(t){this._texture!=null&&t===this._texture.id||(this._texture=T(this._texture),this._textureId=t,this._acquire(this._textureId,r=>this._texture=r))}_acquire(t,r){if(t==null)return void r(null);const e=this._textureRepository.acquire(t);if(X(e))return++this._numLoading,void e.then(a=>{if(this._disposed)return T(a),void r(null);r(a)}).finally(()=>--this._numLoading);r(e)}};class ue extends te{constructor(t=null,r=null,e=null,a=null,i=null,o,c){super(),this.texture=t,this.textureNormal=r,this.textureEmissive=e,this.textureOcclusion=a,this.textureMetallicRoughness=i,this.scale=o,this.normalTextureTransformMatrix=c}}function Ee(s){se(s),s.vertex.code.add(S`vec4 transformPositionWithDepth(mat4 proj, mat4 view, vec3 pos, vec2 nearFar, out float depth) {
vec4 eye = view * vec4(pos, 1.0);
depth = calculateLinearDepth(nearFar,eye.z);
return proj * eye;
}`),s.vertex.code.add(S`vec4 transformPosition(mat4 proj, mat4 view, vec3 pos) {
return proj * (view * vec4(pos, 1.0));
}`)}function de(s){s.vertex.code.add(S`float screenSizePerspectiveViewAngleDependentFactor(float absCosAngle) {
return absCosAngle * absCosAngle * absCosAngle;
}`),s.vertex.code.add(S`vec3 screenSizePerspectiveScaleFactor(float absCosAngle, float distanceToCamera, vec3 params) {
return vec3(
min(params.x / (distanceToCamera - params.y), 1.0),
screenSizePerspectiveViewAngleDependentFactor(absCosAngle),
params.z
);
}`),s.vertex.code.add(S`float applyScreenSizePerspectiveScaleFactorFloat(float size, vec3 factor) {
return mix(size * clamp(factor.x, factor.z, 1.0), size, factor.y);
}`),s.vertex.code.add(S`float screenSizePerspectiveScaleFloat(float size, float absCosAngle, float distanceToCamera, vec3 params) {
return applyScreenSizePerspectiveScaleFactorFloat(
size,
screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params)
);
}`),s.vertex.code.add(S`vec2 applyScreenSizePerspectiveScaleFactorVec2(vec2 size, vec3 factor) {
return mix(size * clamp(factor.x, factor.z, 1.0), size, factor.y);
}`),s.vertex.code.add(S`vec2 screenSizePerspectiveScaleVec2(vec2 size, float absCosAngle, float distanceToCamera, vec3 params) {
return applyScreenSizePerspectiveScaleFactorVec2(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));
}`)}function Ie(s){s.uniforms.add(new U("screenSizePerspective",t=>W(t.screenSizePerspective)))}function fe(s){s.uniforms.add(new U("screenSizePerspectiveAlignment",t=>W(t.screenSizePerspectiveAlignment||t.screenSizePerspective)))}function W(s){return K(ve,s.parameters.divisor,s.parameters.offset,s.minScaleFactor)}const ve=Q();function Be(s,t){const r=s.vertex;t.hasVerticalOffset?(pe(r),t.hasScreenSizePerspective&&(s.include(de),fe(r),ie(s.vertex,t)),r.code.add(S`
      vec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {
        float viewDistance = length((view * vec4(worldPos, 1.0)).xyz);
        ${t.spherical?S`vec3 worldNormal = normalize(worldPos + localOrigin);`:S`vec3 worldNormal = vec3(0.0, 0.0, 1.0);`}
        ${t.hasScreenSizePerspective?S`
            float cosAngle = dot(worldNormal, normalize(worldPos - cameraPosition));
            float verticalOffsetScreenHeight = screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);`:S`
            float verticalOffsetScreenHeight = verticalOffset.x;`}
        // Screen sized offset in world space, used for example for line callouts
        float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);
        return worldNormal * worldOffset;
      }

      vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) {
        return worldPos + calculateVerticalOffset(worldPos, localOrigin);
      }
    `)):r.code.add(S`vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) { return worldPos; }`)}const he=ee();function pe(s){s.uniforms.add(new oe("verticalOffset",(t,r)=>{const{minWorldLength:e,maxWorldLength:a,screenLength:i}=t.verticalOffset,o=Math.tan(.5*r.camera.fovY)/(.5*r.camera.fullViewport[3]),c=r.camera.pixelRatio||1;return Z(he,i*c,o,e,a)}))}function Ve(s,t,r,e=1){const{data:a,indices:i}=s,o=t.typedBuffer,c=t.typedBufferStride,n=i.length;if(r*=c,e===1)for(let u=0;u<n;++u)o[r]=a[i[u]],r+=c;else for(let u=0;u<n;++u){const l=a[i[u]];for(let d=0;d<e;d++)o[r]=l,r+=c}}function q(s,t,r){const{data:e,indices:a}=s,i=t.typedBuffer,o=t.typedBufferStride,c=a.length;r*=o;for(let n=0;n<c;++n){const u=2*a[n];i[r]=e[u],i[r+1]=e[u+1],r+=o}}function Y(s,t,r,e){const{data:a,indices:i}=s,o=t.typedBuffer,c=t.typedBufferStride,n=i.length;if(r*=c,e==null||e===1)for(let u=0;u<n;++u){const l=3*i[u];o[r]=a[l],o[r+1]=a[l+1],o[r+2]=a[l+2],r+=c}else for(let u=0;u<n;++u){const l=3*i[u];for(let d=0;d<e;++d)o[r]=a[l],o[r+1]=a[l+1],o[r+2]=a[l+2],r+=c}}function J(s,t,r,e=1){const{data:a,indices:i}=s,o=t.typedBuffer,c=t.typedBufferStride,n=i.length;if(r*=c,e===1)for(let u=0;u<n;++u){const l=4*i[u];o[r]=a[l],o[r+1]=a[l+1],o[r+2]=a[l+2],o[r+3]=a[l+3],r+=c}else for(let u=0;u<n;++u){const l=4*i[u];for(let d=0;d<e;++d)o[r]=a[l],o[r+1]=a[l+1],o[r+2]=a[l+2],o[r+3]=a[l+3],r+=c}}function De(s,t,r){const e=s.typedBuffer,a=s.typedBufferStride;t*=a;for(let i=0;i<r;++i)e[t]=0,e[t+1]=0,e[t+2]=0,e[t+3]=0,t+=a}function ge(s,t,r,e,a=1){if(!t)return void Y(s,r,e,a);const{data:i,indices:o}=s,c=r.typedBuffer,n=r.typedBufferStride,u=o.length,l=t[0],d=t[1],O=t[2],C=t[4],F=t[5],L=t[6],E=t[8],I=t[9],B=t[10],N=t[12],A=t[13],y=t[14];e*=n;let P=0,g=0,h=0;const x=H(t)?v=>{P=i[v]+N,g=i[v+1]+A,h=i[v+2]+y}:v=>{const f=i[v],m=i[v+1],p=i[v+2];P=l*f+C*m+E*p+N,g=d*f+F*m+I*p+A,h=O*f+L*m+B*p+y};if(a===1)for(let v=0;v<u;++v)x(3*o[v]),c[e]=P,c[e+1]=g,c[e+2]=h,e+=n;else for(let v=0;v<u;++v){x(3*o[v]);for(let f=0;f<a;++f)c[e]=P,c[e+1]=g,c[e+2]=h,e+=n}}function xe(s,t,r,e,a=1){if(!t)return void Y(s,r,e,a);const{data:i,indices:o}=s,c=t,n=r.typedBuffer,u=r.typedBufferStride,l=o.length,d=c[0],O=c[1],C=c[2],F=c[4],L=c[5],E=c[6],I=c[8],B=c[9],N=c[10],A=!k(c),y=1e-6,P=1-y;e*=u;let g=0,h=0,x=0;const v=H(c)?f=>{g=i[f],h=i[f+1],x=i[f+2]}:f=>{const m=i[f],p=i[f+1],w=i[f+2];g=d*m+F*p+I*w,h=O*m+L*p+B*w,x=C*m+E*p+N*w};if(a===1)if(A)for(let f=0;f<l;++f){v(3*o[f]);const m=g*g+h*h+x*x;if(m<P&&m>y){const p=1/Math.sqrt(m);n[e]=g*p,n[e+1]=h*p,n[e+2]=x*p}else n[e]=g,n[e+1]=h,n[e+2]=x;e+=u}else for(let f=0;f<l;++f)v(3*o[f]),n[e]=g,n[e+1]=h,n[e+2]=x,e+=u;else for(let f=0;f<l;++f){if(v(3*o[f]),A){const m=g*g+h*h+x*x;if(m<P&&m>y){const p=1/Math.sqrt(m);g*=p,h*=p,x*=p}}for(let m=0;m<a;++m)n[e]=g,n[e+1]=h,n[e+2]=x,e+=u}}function me(s,t,r,e,a=1){if(!t)return void J(s,r,e,a);const{data:i,indices:o}=s,c=t,n=r.typedBuffer,u=r.typedBufferStride,l=o.length,d=c[0],O=c[1],C=c[2],F=c[4],L=c[5],E=c[6],I=c[8],B=c[9],N=c[10],A=!k(c),y=1e-6,P=1-y;if(e*=u,a===1)for(let g=0;g<l;++g){const h=4*o[g],x=i[h],v=i[h+1],f=i[h+2],m=i[h+3];let p=d*x+F*v+I*f,w=O*x+L*v+B*f,b=C*x+E*v+N*f;if(A){const $=p*p+w*w+b*b;if($<P&&$>y){const R=1/Math.sqrt($);p*=R,w*=R,b*=R}}n[e]=p,n[e+1]=w,n[e+2]=b,n[e+3]=m,e+=u}else for(let g=0;g<l;++g){const h=4*o[g],x=i[h],v=i[h+1],f=i[h+2],m=i[h+3];let p=d*x+F*v+I*f,w=O*x+L*v+B*f,b=C*x+E*v+N*f;if(A){const $=p*p+w*w+b*b;if($<P&&$>y){const R=1/Math.sqrt($);p*=R,w*=R,b*=R}}for(let $=0;$<a;++$)n[e]=p,n[e+1]=w,n[e+2]=b,n[e+3]=m,e+=u}}function Se(s,t,r,e,a=1){const{data:i,indices:o}=s,c=r.typedBuffer,n=r.typedBufferStride,u=o.length;if(e*=n,t!==i.length||t!==4)if(a!==1)if(t!==4)for(let l=0;l<u;++l){const d=3*o[l];for(let O=0;O<a;++O)c[e]=i[d],c[e+1]=i[d+1],c[e+2]=i[d+2],c[e+3]=255,e+=n}else for(let l=0;l<u;++l){const d=4*o[l];for(let O=0;O<a;++O)c[e]=i[d],c[e+1]=i[d+1],c[e+2]=i[d+2],c[e+3]=i[d+3],e+=n}else{if(t===4){for(let l=0;l<u;++l){const d=4*o[l];c[e]=i[d],c[e+1]=i[d+1],c[e+2]=i[d+2],c[e+3]=i[d+3],e+=n}return}for(let l=0;l<u;++l){const d=3*o[l];c[e]=i[d],c[e+1]=i[d+1],c[e+2]=i[d+2],c[e+3]=255,e+=n}}else{c[e]=i[0],c[e+1]=i[1],c[e+2]=i[2],c[e+3]=i[3];const l=new Uint32Array(r.typedBuffer.buffer,r.start),d=n/4,O=l[e/=4];e+=d;const C=u*a;for(let F=1;F<C;++F)l[e]=O,e+=d}}function Oe(s,t,r){const{data:e,indices:a}=s,i=t.typedBuffer,o=t.typedBufferStride,c=a.length,n=e[0];r*=o;for(let u=0;u<c;++u)i[r]=n,r+=o}function ze(s,t,r,e,a=1){const i=t.typedBuffer,o=t.typedBufferStride;if(e*=o,a===1)for(let c=0;c<r;++c)i[e]=s[0],i[e+1]=s[1],i[e+2]=s[2],i[e+3]=s[3],e+=o;else for(let c=0;c<r;++c)for(let n=0;n<a;++n)i[e]=s[0],i[e+1]=s[1],i[e+2]=s[2],i[e+3]=s[3],e+=o}function _e(s,t,r,e,a,i){var o;for(const c of t.fields.keys()){const n=s.attributes.get(c),u=n==null?void 0:n.indices;if(n&&u)we(c,n,r,e,a,i);else if(c===_.OBJECTANDLAYERIDCOLOR&&s.objectAndLayerIdColor!=null){const l=(o=s.attributes.get(_.POSITION))==null?void 0:o.indices;if(l){const d=l.length,O=a.getField(c,G);ze(s.objectAndLayerIdColor,O,d,i)}}}}function we(s,t,r,e,a,i){switch(s){case _.POSITION:{z(t.size===3);const o=a.getField(s,M);z(!!o,`No buffer view for ${s}`),o&&ge(t,r,o,i);break}case _.NORMAL:{z(t.size===3);const o=a.getField(s,M);z(!!o,`No buffer view for ${s}`),o&&xe(t,e,o,i);break}case _.NORMALCOMPRESSED:{z(t.size===2);const o=a.getField(s,le);z(!!o,`No buffer view for ${s}`),o&&q(t,o,i);break}case _.UV0:{z(t.size===2);const o=a.getField(s,ne);z(!!o,`No buffer view for ${s}`),o&&q(t,o,i);break}case _.COLOR:case _.SYMBOLCOLOR:{const o=a.getField(s,G);z(!!o,`No buffer view for ${s}`),z(t.size===3||t.size===4),!o||t.size!==3&&t.size!==4||Se(t,t.size,o,i);break}case _.COLORFEATUREATTRIBUTE:{const o=a.getField(s,ae);z(!!o,`No buffer view for ${s}`),z(t.size===1),o&&t.size===1&&Oe(t,o,i);break}case _.TANGENT:{z(t.size===4);const o=a.getField(s,D);z(!!o,`No buffer view for ${s}`),o&&me(t,e,o,i);break}case _.PROFILERIGHT:case _.PROFILEUP:case _.PROFILEVERTEXANDNORMAL:case _.FEATUREVALUE:{z(t.size===4);const o=a.getField(s,D);z(!!o,`No buffer view for ${s}`),o&&J(t,o,i)}}}const ye=j(1,1,0,1),Pe=j(1,0,1,1);function Me(s){s.fragment.uniforms.add(new ce("depthTexture",(t,r)=>r.mainDepth)),s.fragment.constants.add("occludedHighlightFlag","vec4",ye).add("unoccludedHighlightFlag","vec4",Pe),s.fragment.code.add(S`void outputHighlight() {
float sceneDepth = float(texelFetch(depthTexture, ivec2(gl_FragCoord.xy), 0).x);
if (gl_FragCoord.z > sceneDepth + 5e-7) {
fragColor = occludedHighlightFlag;
} else {
fragColor = unoccludedHighlightFlag;
}
}`)}class qe{constructor(t){this.vertexBufferLayout=t}elementCount(t){return t.attributes.get(_.POSITION).indices.length}write(t,r,e,a,i){_e(e,this.vertexBufferLayout,t,r,a,i)}}function He(s,t){t.hasVertexColors?(s.attributes.add(_.COLOR,"vec4"),s.varyings.add("vColor","vec4"),s.vertex.code.add(S`void forwardVertexColor() { vColor = color; }`),s.vertex.code.add(S`void forwardNormalizedVertexColor() { vColor = color * 0.003921568627451; }`)):s.vertex.code.add(S`void forwardVertexColor() {}
void forwardNormalizedVertexColor() {}`)}export{we as A,_e as E,xe as O,ze as R,Se as S,Me as a,ge as b,Be as c,Ve as d,He as e,pe as f,fe as g,ye as h,Pe as i,ue as l,Ee as o,J as p,qe as r,de as s,Ie as t,Te as u,De as y};
