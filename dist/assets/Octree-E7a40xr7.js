import{ay as it,bI as R,dj as I,di as P,dC as J,cj as V,dl as st,bW as H,ci as _}from"./index-8ERthB3p.js";import{s as F}from"./frustum-BrAPXuhm.js";import{O as w,p as G,Z as f,V as q,I as U,w as M}from"./sphere-Bf4ezJdT.js";import{i as Z}from"./Util-B8vYs4k8.js";class E{get bounds(){return this._root.bounds}get halfSize(){return this._root.halfSize}get root(){return this._root.node}get maximumObjectsPerNode(){return this._maximumObjectsPerNode}get maximumDepth(){return this._maximumDepth}get objectCount(){return this._objectCount}constructor(t,e){this.objectToBoundingSphere=t,this._maximumObjectsPerNode=10,this._maximumDepth=20,this._degenerateObjects=new Set,this._root=new d,this._objectCount=0,e&&(e.maximumObjectsPerNode!==void 0&&(this._maximumObjectsPerNode=e.maximumObjectsPerNode),e.maximumDepth!==void 0&&(this._maximumDepth=e.maximumDepth))}destroy(){this._degenerateObjects.clear(),d.clearPool(),W[0]=null,T.prune(),z.prune()}add(t,e=t.length){this._objectCount+=e,this._grow(t,e);const n=d.acquire();for(let o=0;o<e;o++){const i=t[o];this._isDegenerate(i)?this._degenerateObjects.add(i):(n.init(this._root),this._add(i,n))}d.release(n)}remove(t,e=null){this._objectCount-=t.length;const n=d.acquire();for(const o of t){const i=e??w(this.objectToBoundingSphere(o),lt);B(i[3])?(n.init(this._root),this._remove(o,i,n)):this._degenerateObjects.delete(o)}d.release(n),this._shrink()}update(t,e){if(!B(e[3])&&this._isDegenerate(t))return;const n=dt(t);this.remove(n,e),this.add(n)}forEachAlongRay(t,e,n){const o=G(t,e);this._forEachNode(this._root,i=>{if(!this._intersectsNode(o,i))return!1;const h=i.node;return h.terminals.forAll(a=>{this._intersectsObject(o,a)&&n(a)}),h.residents!==null&&h.residents.forAll(a=>{this._intersectsObject(o,a)&&n(a)}),!0})}forEachAlongRayWithVerticalOffset(t,e,n,o){const i=G(t,e);this._forEachNode(this._root,h=>{if(!this._intersectsNodeWithOffset(i,h,o))return!1;const a=h.node;return a.terminals.forAll(s=>{this._intersectsObjectWithOffset(i,s,o)&&n(s)}),a.residents!==null&&a.residents.forAll(s=>{this._intersectsObjectWithOffset(i,s,o)&&n(s)}),!0})}forEach(t){this._forEachNode(this._root,e=>{const n=e.node;return n.terminals.forAll(t),n.residents!==null&&n.residents.forAll(t),!0}),this._degenerateObjects.forEach(t)}forEachDegenerateObject(t){this._degenerateObjects.forEach(t)}findClosest(t,e,n,o=()=>!0,i=1/0){let h=1/0,a=1/0,s=null;const u=y(t,e),m=l=>{if(--i,!o(l))return;const p=this.objectToBoundingSphere(l);if(!F(n,p))return;const O=N(t,e,f(p)),D=O-p[3],c=O+p[3];D<h&&(h=D,a=c,s=l)};return this._forEachNodeDepthOrdered(this._root,l=>{if(i<=0||!F(n,l.bounds)||(I(S,u,l.halfSize),P(S,S,f(l.bounds)),N(t,e,S)>a))return!1;const p=l.node;return p.terminals.forAll(O=>m(O)),p.residents!==null&&p.residents.forAll(O=>m(O)),!0},t,e),s}forEachInDepthRange(t,e,n,o,i,h,a){let s=-1/0,u=1/0;const m={setRange:c=>{n===E.DepthOrder.FRONT_TO_BACK?(s=Math.max(s,c.near),u=Math.min(u,c.far)):(s=Math.max(s,-c.far),u=Math.min(u,-c.near))}};m.setRange(o);const l=N(e,n,t),p=y(e,n),O=y(e,-n),D=c=>{if(!a(c))return;const j=this.objectToBoundingSphere(c),A=f(j),K=N(e,n,A)-l,nt=K-j[3],ot=K+j[3];nt>u||ot<s||!F(h,j)||i(c,m)};this._forEachNodeDepthOrdered(this._root,c=>{if(!F(h,c.bounds)||(I(S,p,c.halfSize),P(S,S,f(c.bounds)),N(e,n,S)-l>u)||(I(S,O,c.halfSize),P(S,S,f(c.bounds)),N(e,n,S)-l<s))return!1;const j=c.node;return j.terminals.forAll(A=>D(A)),j.residents!==null&&j.residents.forAll(A=>D(A)),!0},e,n)}forEachNode(t){this._forEachNode(this._root,e=>t(e.node,e.bounds,e.halfSize,e.depth))}forEachNeighbor(t,e){const n=q(e),o=f(e),i=s=>{const u=this.objectToBoundingSphere(s),m=q(u),l=n+m;return!(J(f(u),o)-l*l<=0)||t(s)};let h=!0;const a=s=>{h&&(h=i(s))};this._forEachNode(this._root,s=>{const u=q(s.bounds),m=n+u;if(J(f(s.bounds),o)-m*m>0)return!1;const l=s.node;return l.terminals.forAll(a),h&&l.residents!==null&&l.residents.forAll(a),h}),h&&this.forEachDegenerateObject(a)}_intersectsNode(t,e){return v(f(e.bounds),2*-e.halfSize,b),v(f(e.bounds),2*e.halfSize,g),Z(t.origin,t.direction,b,g)}_intersectsNodeWithOffset(t,e,n){return v(f(e.bounds),2*-e.halfSize,b),v(f(e.bounds),2*e.halfSize,g),n.applyToMinMax(b,g),Z(t.origin,t.direction,b,g)}_intersectsObject(t,e){const n=this.objectToBoundingSphere(e);return!(n[3]>0)||U(n,t)}_intersectsObjectWithOffset(t,e,n){const o=this.objectToBoundingSphere(e);return!(o[3]>0)||U(n.applyToBoundingSphere(o),t)}_forEachNode(t,e){let n=d.acquire().init(t);const o=[n];for(;o.length!==0;){if(n=o.pop(),e(n)&&!n.isLeaf())for(let i=0;i<n.node.children.length;i++)n.node.children[i]&&o.push(d.acquire().init(n).advance(i));d.release(n)}}_forEachNodeDepthOrdered(t,e,n,o=E.DepthOrder.FRONT_TO_BACK){let i=d.acquire().init(t);const h=[i];for(at(n,o,Y);h.length!==0;){if(i=h.pop(),e(i)&&!i.isLeaf())for(let a=7;a>=0;--a){const s=Y[a];i.node.children[s]&&h.push(d.acquire().init(i).advance(s))}d.release(i)}}_remove(t,e,n){T.clear();const o=n.advanceTo(e,(i,h)=>{T.push(i.node),T.push(h)})?n.node.terminals:n.node.residents;if(o.removeUnordered(t),o.length===0)for(let i=T.length-2;i>=0;i-=2){const h=T.data[i],a=T.data[i+1];if(!this._purge(h,a))break}}_nodeIsEmpty(t){if(t.terminals.length!==0)return!1;if(t.residents!==null)return t.residents.length===0;for(let e=0;e<t.children.length;e++)if(t.children[e])return!1;return!0}_purge(t,e){return e>=0&&(t.children[e]=null),!!this._nodeIsEmpty(t)&&(t.residents===null&&(t.residents=new R({shrink:!0})),!0)}_add(t,e){e.advanceTo(this.objectToBoundingSphere(t))?e.node.terminals.push(t):(e.node.residents.push(t),e.node.residents.length>this._maximumObjectsPerNode&&e.depth<this._maximumDepth&&this._split(e))}_split(t){const e=t.node.residents;t.node.residents=null;for(let n=0;n<e.length;n++){const o=d.acquire().init(t);this._add(e.at(n),o),d.release(o)}}_grow(t,e){if(e!==0&&(Q(t,e,n=>this.objectToBoundingSphere(n),x),B(x[3])&&!this._fitsInsideTree(x)))if(this._nodeIsEmpty(this._root.node))w(x,this._root.bounds),this._root.halfSize=1.25*this._root.bounds[3],this._root.updateBoundsRadiusFromHalfSize();else{const n=this._rootBoundsForRootAsSubNode(x);this._placingRootViolatesMaxDepth(n)?this._rebuildTree(x,n):this._growRootAsSubNode(n),d.release(n)}}_rebuildTree(t,e){V(f(k),f(e.bounds)),k[3]=e.halfSize,Q([t,k],2,o=>o,L);const n=d.acquire().init(this._root);this._root.initFrom(null,L,L[3]),this._root.increaseHalfSize(1.25),this._forEachNode(n,o=>(this.add(o.node.terminals.data,o.node.terminals.length),o.node.residents!==null&&this.add(o.node.residents.data,o.node.residents.length),!0)),d.release(n)}_placingRootViolatesMaxDepth(t){const e=Math.log(t.halfSize/this._root.halfSize)*Math.LOG2E;let n=0;return this._forEachNode(this._root,o=>(n=Math.max(n,o.depth),n+e<=this._maximumDepth)),n+e>this._maximumDepth}_rootBoundsForRootAsSubNode(t){const e=t[3],n=t;let o=-1/0;const i=this._root.bounds,h=this._root.halfSize;for(let s=0;s<3;s++){const u=i[s]-h-(n[s]-e),m=n[s]+e-(i[s]+h),l=Math.max(0,Math.ceil(u/(2*h))),p=Math.max(0,Math.ceil(m/(2*h)))+1,O=2**Math.ceil(Math.log(l+p)*Math.LOG2E);o=Math.max(o,O),C[s].min=l,C[s].max=p}for(let s=0;s<3;s++){let u=C[s].min,m=C[s].max;const l=(o-(u+m))/2;u+=Math.ceil(l),m+=Math.floor(l);const p=i[s]-h-u*h*2;$[s]=p+(m+u)*h}const a=o*h;return $[3]=a*et,d.acquire().initFrom(null,$,a,0)}_growRootAsSubNode(t){const e=this._root.node;V(f(x),f(this._root.bounds)),x[3]=this._root.halfSize,this._root.init(t),t.advanceTo(x,null,!0),t.node.children=e.children,t.node.residents=e.residents,t.node.terminals=e.terminals}_shrink(){for(;;){const t=this._findShrinkIndex();if(t===-1)break;this._root.advance(t),this._root.depth=0}}_findShrinkIndex(){if(this._root.node.terminals.length!==0||this._root.isLeaf())return-1;let t=null;const e=this._root.node.children;let n=0,o=0;for(;o<e.length&&t==null;)n=o++,t=e[n];for(;o<e.length;)if(e[o++])return-1;return n}_isDegenerate(t){return!B(this.objectToBoundingSphere(t)[3])}_fitsInsideTree(t){const e=this._root.bounds,n=this._root.halfSize;return t[3]<=n&&t[0]>=e[0]-n&&t[0]<=e[0]+n&&t[1]>=e[1]-n&&t[1]<=e[1]+n&&t[2]>=e[2]-n&&t[2]<=e[2]+n}toJSON(){const{maximumDepth:t,maximumObjectsPerNode:e,_objectCount:n}=this,o=this._nodeToJSON(this._root.node);return{maximumDepth:t,maximumObjectsPerNode:e,objectCount:n,root:{bounds:this._root.bounds,halfSize:this._root.halfSize,depth:this._root.depth,node:o}}}_nodeToJSON(t){var i,h;const e=t.children.map(a=>a?this._nodeToJSON(a):null),n=(i=t.residents)==null?void 0:i.map(a=>this.objectToBoundingSphere(a)),o=(h=t.terminals)==null?void 0:h.map(a=>this.objectToBoundingSphere(a));return{children:e,residents:n,terminals:o}}static fromJSON(t){const e=new E(n=>n,{maximumDepth:t.maximumDepth,maximumObjectsPerNode:t.maximumObjectsPerNode});return e._objectCount=t.objectCount,e._root.initFrom(t.root.node,t.root.bounds,t.root.halfSize,t.root.depth),e}}class d{constructor(){this.bounds=M(),this.halfSize=0,this.initFrom(null,null,0,0)}init(t){return this.initFrom(t.node,t.bounds,t.halfSize,t.depth)}initFrom(t,e,n,o=this.depth){return this.node=t??d.createEmptyNode(),e&&w(e,this.bounds),this.halfSize=n,this.depth=o,this}increaseHalfSize(t){this.halfSize*=t,this.updateBoundsRadiusFromHalfSize()}updateBoundsRadiusFromHalfSize(){this.bounds[3]=this.halfSize*et}advance(t){let e=this.node.children[t];e||(e=d.createEmptyNode(),this.node.children[t]=e),this.node=e,this.halfSize/=2,this.depth++;const n=tt[t];return this.bounds[0]+=n[0]*this.halfSize,this.bounds[1]+=n[1]*this.halfSize,this.bounds[2]+=n[2]*this.halfSize,this.updateBoundsRadiusFromHalfSize(),this}advanceTo(t,e,n=!1){for(;;){if(this.isTerminalFor(t))return e&&e(this,-1),!0;if(this.isLeaf()){if(!n)return e&&e(this,-1),!1;this.node.residents=null}const o=this._childIndex(t);e&&e(this,o),this.advance(o)}}isLeaf(){return this.node.residents!=null}isTerminalFor(t){return t[3]>this.halfSize/2}_childIndex(t){const e=this.bounds;return(e[0]<t[0]?1:0)+(e[1]<t[1]?2:0)+(e[2]<t[2]?4:0)}static createEmptyNode(){return{children:[null,null,null,null,null,null,null,null],terminals:new R({shrink:!0}),residents:new R({shrink:!0})}}static acquire(){return d._pool.acquire()}static release(t){d._pool.release(t)}static clearPool(){d._pool.prune()}}function rt(r,t){r[0]=Math.min(r[0],t[0]-t[3]),r[1]=Math.min(r[1],t[1]-t[3]),r[2]=Math.min(r[2],t[2]-t[3])}function ht(r,t){r[0]=Math.max(r[0],t[0]+t[3]),r[1]=Math.max(r[1],t[1]+t[3]),r[2]=Math.max(r[2],t[2]+t[3])}function v(r,t,e){e[0]=r[0]+t,e[1]=r[1]+t,e[2]=r[2]+t}function Q(r,t,e,n){if(t===1){const o=e(r[0]);w(o,n)}else{b[0]=1/0,b[1]=1/0,b[2]=1/0,g[0]=-1/0,g[1]=-1/0,g[2]=-1/0;for(let o=0;o<t;o++){const i=e(r[o]);B(i[3])&&(rt(b,i),ht(g,i))}st(f(n),b,g,.5),n[3]=Math.max(g[0]-b[0],g[1]-b[1],g[2]-b[2])/2}}function at(r,t,e){if(!z.length)for(let n=0;n<8;++n)z.push({index:0,distance:0});for(let n=0;n<8;++n){const o=tt[n];z.data[n].index=n,z.data[n].distance=N(r,t,o)}z.sort((n,o)=>n.distance-o.distance);for(let n=0;n<8;++n)e[n]=z.data[n].index}function y(r,t){let e,n=1/0;for(let o=0;o<8;++o){const i=N(r,t,X[o]);i<n&&(n=i,e=X[o])}return e}function N(r,t,e){return t*(r[0]*e[0]+r[1]*e[1]+r[2]*e[2])}function B(r){return!isNaN(r)&&r!==-1/0&&r!==1/0&&r>0}d._pool=new it(d),function(r){var t;(t=r.DepthOrder||(r.DepthOrder={}))[t.FRONT_TO_BACK=1]="FRONT_TO_BACK",t[t.BACK_TO_FRONT=-1]="BACK_TO_FRONT"}(E||(E={}));const tt=[_(-1,-1,-1),_(1,-1,-1),_(-1,1,-1),_(1,1,-1),_(-1,-1,1),_(1,-1,1),_(-1,1,1),_(1,1,1)],X=[_(-1,-1,-1),_(-1,-1,1),_(-1,1,-1),_(-1,1,1),_(1,-1,-1),_(1,-1,1),_(1,1,-1),_(1,1,1)],et=Math.sqrt(3),W=[null];function dt(r){return W[0]=r,W}const $=M(),S=H(),b=H(),g=H(),T=new R,lt=M(),x=M(),k=M(),L=M(),C=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],z=new R,Y=[0,0,0,0,0,0,0,0],_t=E;export{_t as W};
