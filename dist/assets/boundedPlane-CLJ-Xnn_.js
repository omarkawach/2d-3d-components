import{ci as y,dA as x,cj as u,dj as l,di as p,dg as P,fm as en,dk as h,fn as an,dh as cn,cf as $,dm as B,fo as O,fp as un,fq as gn,fc as m,fr as bn,fs as V,bX as C,dB as D,bW as v,P as fn}from"./index-8ERthB3p.js";import{s as F}from"./ObjectStack-BPo9QGhV.js";import{e as W}from"./mat4f64-Dk4dwAN8.js";import{v as ln,A as G,M as pn}from"./lineSegment-DVvvMBnG.js";import{E as T,v as dn,A as mn,U as z,c as e,T as $n,S as hn,z as In,B as Pn,D as X,J as vn,a as N,F as M,O as Nn}from"./plane-Du3EYICn.js";import{v as Mn}from"./sphere-Bf4ezJdT.js";const j=()=>fn.getLogger("esri.views.3d.support.geometryUtils.boundedPlane");class An{constructor(){this.plane=T(),this.origin=v(),this.basis1=v(),this.basis2=v()}}const Tn=An;function I(n=rn){return{plane:T(n.plane),origin:x(n.origin),basis1:x(n.basis1),basis2:x(n.basis2)}}function wn(n,s,i){const o=Jn.get();return o.origin=n,o.basis1=s,o.basis2=i,o.plane=dn(0,0,0,0),S(o),o}function w(n,s=I()){return L(n.origin,n.basis1,n.basis2,s)}function Sn(n,s){u(s.origin,n.origin),u(s.basis1,n.basis1),u(s.basis2,n.basis2),mn(s.plane,n.plane)}function L(n,s,i,o=I()){return u(o.origin,n),u(o.basis1,s),u(o.basis2,i),S(o),Yn(o,"fromValues()"),o}function S(n){z(n.basis2,n.basis1,n.origin,n.plane)}function Z(n,s,i){n!==i&&w(n,i);const o=l(e.get(),f(n),s);return p(i.origin,i.origin,o),i.plane[3]-=s,i}function _n(n,s,i){return H(s,i),Z(i,q(n,n.origin),i),i}function H(n,s=I()){const i=(n[2]-n[0])/2,o=(n[3]-n[1])/2;return P(s.origin,n[0]+i,n[1]+o,0),P(s.basis1,i,0,0),P(s.basis2,0,o,0),$n(0,0,1,0,s.plane),s}function U(n,s,i){return!!hn(n.plane,s,i)&&on(n,i)}function yn(n,s,i){if(U(n,s,i))return i;const o=K(n,s,e.get());return p(i,s.origin,l(e.get(),s.direction,en(s.origin,o)/h(s.direction))),i}function K(n,s,i){const o=A.get();tn(n,s,o,A.get());let t=Number.POSITIVE_INFINITY;for(const r of k){const a=J(n,r,_.get()),g=e.get();if(In(o,a,g)){const c=an(e.get(),s.origin,g),b=Math.abs(cn($(s.direction,c)));b<t&&(t=b,u(i,g))}}return t===Number.POSITIVE_INFINITY?Q(n,s,i):i}function Q(n,s,i){if(U(n,s,i))return i;const o=A.get(),t=A.get();tn(n,s,o,t);let r=Number.POSITIVE_INFINITY;for(const a of k){const g=J(n,a,_.get()),c=e.get();if(Pn(o,g,c)){const b=Mn(s,c);if(!X(t,c))continue;b<r&&(r=b,u(i,c))}}return Y(n,s.origin)<r&&nn(n,s.origin,i),i}function nn(n,s,i){const o=vn(n.plane,s,e.get()),t=G(R(n,n.basis1),o,-1,1,e.get()),r=G(R(n,n.basis2),o,-1,1,e.get());return B(i,p(e.get(),t,r),n.origin),i}function sn(n,s,i){const{origin:o,basis1:t,basis2:r}=n,a=B(e.get(),s,o),g=N(t,a),c=N(r,a),b=N(f(n),a);return P(i,g,c,b)}function Y(n,s){const i=sn(n,s,e.get()),{basis1:o,basis2:t}=n,r=h(o),a=h(t),g=Math.max(Math.abs(i[0])-r,0),c=Math.max(Math.abs(i[1])-a,0),b=i[2];return g*g+c*c+b*b}function xn(n,s){return Math.sqrt(Y(n,s))}function On(n,s){let i=Number.NEGATIVE_INFINITY;for(const o of k){const t=J(n,o,_.get()),r=pn(t,s);r>i&&(i=r)}return Math.sqrt(i)}function Vn(n,s){return X(n.plane,s)&&on(n,s)}function jn(n,s,i,o){return Un(n,i,o)}function q(n,s){const i=-n.plane[3];return N(f(n),s)-i}function En(n,s,i,o){const t=q(n,s),r=l(qn,f(n),i-t);return p(o,s,r),o}function zn(n,s){return O(n.basis1,s.basis1)&&O(n.basis2,s.basis2)&&O(n.origin,s.origin)}function Bn(n,s,i){return n!==i&&w(n,i),un(d,s),gn(d,d),m(i.basis1,n.basis1,d),m(i.basis2,n.basis2,d),m(M(i.plane),M(n.plane),d),m(i.origin,n.origin,s),Nn(i.plane,i.plane,i.origin),i}function Fn(n,s,i,o){return n!==o&&w(n,o),bn(E,s,i),m(o.basis1,n.basis1,E),m(o.basis2,n.basis2,E),S(o),o}function f(n){return M(n.plane)}function Un(n,s,i){switch(s){case V.X:u(i,n.basis1),C(i,i);break;case V.Y:u(i,n.basis2),C(i,i);break;case V.Z:u(i,f(n))}return i}function on(n,s){const i=B(e.get(),s,n.origin),o=D(n.basis1),t=D(n.basis2),r=$(n.basis1,i),a=$(n.basis2,i);return-r-o<0&&r-o<0&&-a-t<0&&a-t<0}function R(n,s){const i=_.get();return u(i.origin,n.origin),u(i.vector,s),i}function J(n,s,i){const{basis1:o,basis2:t,origin:r}=n,a=l(e.get(),o,s.origin[0]),g=l(e.get(),t,s.origin[1]);p(i.origin,a,g),p(i.origin,i.origin,r);const c=l(e.get(),o,s.direction[0]),b=l(e.get(),t,s.direction[1]);return l(i.vector,p(c,c,b),2),i}function Yn(n,s){Math.abs($(n.basis1,n.basis2)/(h(n.basis1)*h(n.basis2)))>1e-6&&j().warn(s,"Provided basis vectors are not perpendicular"),Math.abs($(n.basis1,f(n)))>1e-6&&j().warn(s,"Basis vectors and plane normal are not perpendicular"),Math.abs(-$(f(n),n.origin)-n.plane[3])>1e-6&&j().warn(s,"Plane offset is not consistent with plane origin")}function tn(n,s,i,o){const t=f(n);z(t,s.direction,s.origin,i),z(M(i),t,s.origin,o)}const rn={plane:T(),origin:y(0,0,0),basis1:y(1,0,0),basis2:y(0,1,0)},A=new F(T),_=new F(ln),qn=v(),Jn=new F(()=>I()),k=[{origin:[-1,-1],direction:[1,0]},{origin:[1,-1],direction:[0,1]},{origin:[1,1],direction:[-1,0]},{origin:[-1,1],direction:[0,-1]}],d=W(),E=W(),Xn=Object.freeze(Object.defineProperty({__proto__:null,BoundedPlaneClass:Tn,altitudeAt:q,axisAt:jn,closestPoint:Q,closestPointOnSilhouette:K,copy:w,copyWithoutVerify:Sn,create:I,distance:xn,distance2:Y,distanceToSilhouette:On,elevate:Z,equals:zn,extrusionContainsPoint:Vn,fromAABoundingRect:H,fromValues:L,intersectRay:U,intersectRayClosestSilhouette:yn,normal:f,projectPoint:nn,projectPointLocal:sn,rotate:Fn,setAltitudeAt:En,setExtent:_n,transform:Bn,up:rn,updateUnboundedPlane:S,wrap:wn},Symbol.toStringTag,{value:"Module"}));export{H as $,Tn as G,L as H,S as J,I as W,w as Z,Xn as _,xn as a,f as d,Bn as l,Fn as m,zn as p,U as s,Vn as u};
