function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = ["assets/ColorMaterial.glsl-uPKQoFFi.js","assets/index-8ERthB3p.js","assets/index-CzRN3C0i.css","assets/mat3-CqxUQBLP.js","assets/mat3f64-BBpwCtoL.js","assets/mat4f64-Dk4dwAN8.js","assets/vec2f64-Diu2Kaa8.js","assets/BufferView-CHYzaV9A.js","assets/vec2-Dt9Foiri.js","assets/Texture-C7A05GrI.js","assets/interfaces-B8ge7Jg9.js","assets/BindType-BmZEZMMh.js","assets/Util-B8vYs4k8.js","assets/enums-DSseSvdG.js","assets/Texture-O7Pyotwx.js","assets/VertexAttribute-BnAa5VW0.js","assets/basicInterfaces-DngWxyLO.js","assets/ShaderTechniqueConfiguration-D3UbJ2mX.js","assets/doublePrecisionUtils-B0owpBza.js","assets/Material-DwPnlQDw.js","assets/ContentObject-BTgEhnct.js","assets/ViewingMode-Dodu7ZZk.js","assets/requestImageUtils-DP1V3HlH.js","assets/InterleavedLayout-s3MgOYN8.js","assets/types-D0PSWh4d.js","assets/VertexColor.glsl-CScvx9pF.js","assets/OrderIndependentTransparency-Cua2R8AE.js","assets/projectVectorToVector-C3SBBDgz.js","assets/projectPointToVector-qKp-AJ2b.js","assets/hydratedFeatures-DqrDm0_F.js","assets/floatRGBA-CCqnXShd.js"]
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}
import{r as Xa,n as k}from"./vec2f64-Diu2Kaa8.js";import{bW as E,dk as Jt,d0 as yr,lI as Hi,bU as Dt,bX as re,dj as se,dm as ae,cj as X,ci as st,o as m,y as b,X as tr,bO as Ks,dE as fi,bR as Ve,fu as it,dg as Q,c7 as Gi,ce as Wi,cd as Ur,c4 as or,fv as Be,q5 as Ka,kB as eo,fp as kt,fm as jr,fq as ea,fo as St,q6 as Bi,ff as ki,cf as Lt,hL as qi,hK as to,g2 as ro,bQ as Ht,g_ as Gt,cg as Le,fn as io,P as zr,q7 as ta,ko as Ke,fc as ye,dA as Zi,di as le,de as mi,bq as so,a0 as ao,dQ as oo,q8 as no,dl as lo,mH as co,bG as wr,q9 as Qi,fB as ho,aT as br,w as Mt,qa as Ar,je as Tt,jf as Rt,fG as Yt,bE as ra,bI as Ae,ju as uo,gJ as ia,cT as Oi,lh as po,c5 as gi,_ as bi,jU as fo,gG as mo,kL as Ji,g4 as go,dh as _o,qb as vo,qc as Yi,hk as Xi,kk as Wt,n_ as yo,bP as wo,cr as Hr,ej as Ki,ct as xo,h3 as Gr,qd as Co,g6 as So}from"./index-8ERthB3p.js";import{r as J,n as Re,t as es}from"./vec3f32-Cw9Q6TO_.js";import{t as To}from"./DoubleArray-068mylUp.js";import{K as Ai,z as Ft,j as et,o as Z,a8 as Wr,a5 as sa,a6 as aa,w as oa,v as ke,y as Di,A as ie,al as Br,am as Ro,t as De,an as ts,b as M,a0 as Dr,ae as Oo,ao as bo,a1 as Ao,Z as Do,I as ct,a as Mi,B as na,n as la,ap as rs,M as Mo,aq as Eo,f as $o,ar as Ei,h as xr,N as Io,a4 as Po,S as Lo,T as Fo,g as No,as as jo,u as zo,i as Vo,P as Uo,e as Ho,k as kr,l as $i,r as Ii,m as Pi,at as Go,af as is,ag as ss,ah as Wo,au as as,av as Bo,aw as ko,ax as qo,ay as Zo,az as os,aA as Qo,s as Jo,aB as Yo,aC as Xo,aD as Ko,aE as en,ai as tn,C as rn,J as sn,c as an,aF as on}from"./Texture-C7A05GrI.js";import{A as ca,l as nn}from"./Indices-DP3oX5Sg.js";import{a as ln,E as rr,j as cn,S as dn,b as nr,V as Me,F as ns}from"./plane-Du3EYICn.js";import{d as hn,p as un,Z as Mr,w as da,_ as pn}from"./sphere-Bf4ezJdT.js";import{t as j}from"./Attribute-B-NAci_J.js";import{e as Nt,r as ha}from"./ContentObject-BTgEhnct.js";import{I as we,r as ls,n as cs,a as ds}from"./Geometry-CqGtfd4N.js";import{s as pe,m as fn,u as mn,c as dt,f as lr,l as gn}from"./Util-B8vYs4k8.js";import{e as y,E as _n}from"./VertexAttribute-BnAa5VW0.js";import{o as Ge,e as W}from"./mat4f64-Dk4dwAN8.js";import{R as vn}from"./computeTranslationToOriginAndRotation-BbJd4iYX.js";import{b as yn,f as wn,c as cr,t as hs,G as xn,i as Cn}from"./ElevationProvider-Bd4qfXCi.js";import{u as Sn}from"./hydratedFeatures-DqrDm0_F.js";import{l as Li}from"./ViewingMode-Dodu7ZZk.js";import{c as Tn,h as Oe,O as ua,t as qr}from"./Material-DwPnlQDw.js";import{o as w,n as pa}from"./interfaces-B8ge7Jg9.js";import{b as Rn,d as us,y as ps}from"./axisAngleDegrees-CaSFQR2z.js";import{p as ht,i as On}from"./weather-D00pIeau.js";import{I as bn}from"./RenderState-DaVlEYWY.js";import{a as fa}from"./BindType-BmZEZMMh.js";import{t as Fi}from"./NestedMap-DgiGbX8E.js";import{t as ma,r as P}from"./ShaderTechniqueConfiguration-D3UbJ2mX.js";import{r as Ni,E as An,o as _i,u as qe,l as xt,_ as zt,b as fs,e as Ct,j as ne,x as Dn,v as ms}from"./vec2-Dt9Foiri.js";import{H as Mn,N as En,L as $n,j as dr}from"./frustum-BrAPXuhm.js";import{m as ga}from"./mathUtils-iSLnUy_4.js";import{i as In,t as gs,a as Pn}from"./basicInterfaces-DngWxyLO.js";import{W as Ln}from"./Octree-E7a40xr7.js";import{v as _a,M as Fn,b as Zr,d as Nn}from"./lineSegment-DVvvMBnG.js";import{H as jn}from"./InterleavedLayout-s3MgOYN8.js";import{o as Ue,S as tt,c as Qr,A as zn,l as Vn,a as Un,E as Hn,_ as Et,b as Gn,g as Wn,s as Bn}from"./OrderIndependentTransparency-Cua2R8AE.js";import{o as va}from"./floatRGBA-CCqnXShd.js";import{G as ya,D as Er,E as _s,M as kn,_ as $r,F as qn,R as Ot,L as Zn}from"./enums-DSseSvdG.js";import{e as ji,m as Xt}from"./Texture-O7Pyotwx.js";import{e as Qn}from"./mat3f64-BBpwCtoL.js";import{i as Jn}from"./Intersector-8rpRuT_8.js";import{r as Yn}from"./glUtil-DS73TAjp.js";import{o as Xn}from"./VertexArrayObject-Cv4RwmVi.js";import{h as Kn}from"./BufferObject-CaEbWulZ.js";import{I as el,C as tl}from"./Scheduler-DaHJO6l7.js";function rl(e){e.fragment.code.add(w`const float GAMMA = 2.2;
const float INV_GAMMA = 0.4545454545;
vec4 delinearizeGamma(vec4 color) {
return vec4(pow(color.rgb, vec3(INV_GAMMA)), color.w);
}
vec3 linearizeGamma(vec3 color) {
return pow(color, vec3(GAMMA));
}`)}let il=class extends Xn{};var rt,Ir;function hh(e){return(e==null?void 0:e.cubeMap)!=null}function sl(e){return e!=null&&!e.running}(function(e){e[e.RENDERING=0]="RENDERING",e[e.FADING=1]="FADING",e[e.FINISHED=2]="FINISHED"})(rt||(rt={})),function(e){e[e.RG=0]="RG",e[e.BA=1]="BA"}(Ir||(Ir={}));let al=class{constructor(){this.readChannels=Ir.RG,this.renderingStage=rt.FINISHED,this.startTime=0,this.startTimeHeightFade=0,this.cameraPositionLastFrame=E(),this.parallax=new vs,this.parallaxNew=new vs,this.pointOnGround=E(),this.fadeMode=G.HIDE,this.fadeFactor=0,this.opacity=0}updateParallax(t){const r=this.parallax,i=Jt(t.eye);if(r.radiusCurvatureCorrectionFactor=.84*Math.sqrt(Math.max(i*i-yr.radius*yr.radius,0))/i,us(ys,r.anchorPointClouds,ut),Hi(r.transform,Ge,ut[3],ps(ut)),this.fadeMode===G.CROSS_FADE){const s=this.parallaxNew;us(ys,s.anchorPointClouds,ut),Hi(s.transform,Ge,ut[3],ps(ut))}}updateFading(t,r,i,s){this.isFading&&this._advanceFading(i,s),this._evaluateFading(t,r,i)}_evaluateFading(t,r,i){const s=t.relativeElevation,a=this._calculateDistanceToAnchorPoint(t);if((s>1.7*ht||s<-ht||a>dl)&&this.opacity>0)this._setFade(G.HIDE,i);else if(!this.isFading){if((s>ht||s<-.35*ht||a>cl)&&this.opacity>0)this._setFade(G.FADE_OUT,i);else if(s<=ht&&s>=-.35*ht&&r===bn.IDLE&&sl(this.data)){if(this.opacity===0)return void this._setFade(G.FADE_IN,i);(a>ll||this.renderingStage===rt.FADING)&&this._setFade(G.CROSS_FADE,i)}}}_advanceFading(t,r){this._switchReadChannels(),this._updateAnchorPoint(),this._advanceFadingFactorAndOpacity(t,r)}_advanceFadingFactorAndOpacity(t,r){if(this.fadeFactor<1)return this.fadeFactor=r?Dt((t-this.startTime)/(nl*r),0,1):1,this.fadeMode===G.FADE_OUT&&(this.opacity=1-this.fadeFactor),this.fadeMode===G.FADE_IN&&(this.opacity=this.fadeFactor),void(this.fadeMode===G.CROSS_FADE&&(this.opacity=1));this.fadeFactor=0,this.fadeMode===G.FADE_OUT&&(this.opacity=0),this.fadeMode===G.FADE_IN&&(this.opacity=1),this.fadeMode===G.CROSS_FADE&&(this.opacity=1),this.fadeMode=G.NONE}_switchReadChannels(){const t=this.fadeMode===G.CROSS_FADE&&this.fadeFactor===1,r=this.fadeMode===G.FADE_IN&&this.fadeFactor===0;this.renderingStage===rt.FADING&&(t||r)&&(this.readChannels=1-this.readChannels,this.renderingStage=rt.FINISHED)}_calculateDistanceToAnchorPoint(t){return re(this.pointOnGround,t.eye),se(this.pointOnGround,this.pointOnGround,yr.radius),Jt(ae(ol,this.parallax.anchorPointClouds,this.pointOnGround))}_updateAnchorPoint(){this.fadeMode===G.CROSS_FADE&&(this.fadeFactor===0&&X(this.parallaxNew.anchorPointClouds,this.pointOnGround),this.fadeFactor===1&&X(this.parallax.anchorPointClouds,this.parallaxNew.anchorPointClouds)),this.fadeMode===G.FADE_IN&&this.fadeFactor===0&&X(this.parallax.anchorPointClouds,this.pointOnGround)}_setFade(t,r){switch(t){case G.HIDE:this.opacity=0;break;case G.FADE_OUT:this.opacity=1;break;case G.FADE_IN:this.opacity=0;break;case G.CROSS_FADE:this.opacity=1}this.fadeMode=t,this.fadeFactor=0,this.startTime=r}get isFading(){return this.fadeMode===G.FADE_OUT||this.fadeMode===G.FADE_IN||this.fadeMode===G.CROSS_FADE}};var G;(function(e){e[e.NONE=0]="NONE",e[e.HIDE=1]="HIDE",e[e.FADE_OUT=2]="FADE_OUT",e[e.FADE_IN=3]="FADE_IN",e[e.CROSS_FADE=4]="CROSS_FADE"})(G||(G={}));let vs=class{constructor(){this.anchorPointClouds=E(),this.radiusCurvatureCorrectionFactor=0,this.transform=W()}};const ys=st(0,0,1),ut=Rn(),ol=E(),nl=1.25,ll=34e3,cl=64e3,dl=2e5;let hl=class extends Ai{constructor(t,r){super(t,"samplerCube",fa.Pass,(i,s,a)=>i.bindTexture(t,r(s,a)))}};function ul(e){const t=e.fragment;t.uniforms.add(new Ft("rotationMatrixClouds",(r,i)=>i.cloudsFade.parallax.transform),new Ft("rotationMatrixCloudsCrossFade",(r,i)=>i.cloudsFade.parallaxNew.transform),new et("anchorPosition",(r,i)=>i.cloudsFade.parallax.anchorPointClouds),new et("anchorPositionCrossFade",(r,i)=>i.cloudsFade.parallaxNew.anchorPointClouds),new Z("cloudsHeight",()=>On),new Z("radiusCurvatureCorrectionFactor",(r,i)=>i.cloudsFade.parallax.radiusCurvatureCorrectionFactor),new Z("totalFadeInOut",(r,i)=>1-i.cloudsFade.opacity),new Z("crossFadeAnchorFactor",(r,i)=>Dt(i.cloudsFade.fadeFactor,0,1)),new hl("cubeMap",(r,i)=>{var s,a;return((a=(s=i.cloudsFade.data)==null?void 0:s.cubeMap)==null?void 0:a.colorTexture)??null}),new Wr("crossFade",(r,i)=>i.cloudsFade.fadeMode===G.CROSS_FADE),new Wr("readChannelsRG",(r,i)=>i.cloudsFade.readChannels===Ir.RG),new Wr("fadeTextureChannels",(r,i)=>i.cloudsFade.renderingStage===rt.FADING)),t.constants.add("planetRadius","float",yr.radius),t.code.add(w`vec3 intersectWithCloudLayer(vec3 dir, vec3 cameraPosition, vec3 spherePos)
{
float radiusClouds = planetRadius + cloudsHeight;
float B = 2.0 * dot(cameraPosition, dir);
float C = dot(cameraPosition, cameraPosition) - radiusClouds * radiusClouds;
float det = B * B - 4.0 * C;
float pointIntDist = max(0.0, 0.5 *(-B + sqrt(det)));
vec3 intersectionPont = cameraPosition + dir * pointIntDist;
intersectionPont =  intersectionPont - spherePos;
return intersectionPont;
}`),t.code.add(w`vec3 correctForPlanetCurvature(vec3 dir)
{
dir.z = dir.z*(1.-radiusCurvatureCorrectionFactor) + radiusCurvatureCorrectionFactor;
return dir;
}`),t.code.add(w`vec3 rotateDirectionToAnchorPoint(mat4 rotMat, vec3 inVec)
{
return (rotMat * vec4(inVec, 0.0)).xyz;
}`),sa(t),aa(t),t.code.add(w`const float SUNSET_TRANSITION_FACTOR = 0.3;
const vec3 RIM_COLOR = vec3(0.28, 0.175, 0.035);
const float RIM_SCATTERING_FACTOR = 140.0;
const float BACKLIGHT_FACTOR = 0.2;
const float BACKLIGHT_SCATTERING_FACTOR = 10.0;
const float BACKLIGHT_TRANSITION_FACTOR = 0.3;
vec3 calculateCloudColor(vec3 cameraPosition, vec3 worldSpaceRay, vec4 clouds)
{
float upDotLight = dot(normalize(cameraPosition), normalize(mainLightDirection));
float dirDotLight = max(dot(normalize(-worldSpaceRay), normalize(mainLightDirection)), 0.0);
float sunsetTransition = clamp(pow(max(upDotLight, 0.0), SUNSET_TRANSITION_FACTOR), 0.0, 1.0);
vec3 ambientLight = calculateAmbientIrradiance(normalize(cameraPosition),  0.0);
vec3 mainLight = evaluateMainLighting(normalize(cameraPosition),  0.0);
vec3 combinedLight = clamp((mainLightIntensity + ambientLight )/PI, vec3(0.0), vec3(1.0));
vec3 baseCloudColor = pow(combinedLight * pow(clouds.xyz, vec3(GAMMA)), vec3(INV_GAMMA));
float scatteringMod = max(clouds.a < 0.5 ? clouds.a / 0.5 : - clouds.a / 0.5 + 2.0, 0.0);
float rimLightIntensity = 0.5 + 0.5 *pow(max(upDotLight, 0.0), 0.35);
vec3 directSunScattering = RIM_COLOR * rimLightIntensity * (pow(dirDotLight, RIM_SCATTERING_FACTOR)) * scatteringMod;
float additionalLight = BACKLIGHT_FACTOR * pow(dirDotLight, BACKLIGHT_SCATTERING_FACTOR) * (1. - pow(sunsetTransition, BACKLIGHT_TRANSITION_FACTOR)) ;
return vec3(baseCloudColor * (1. + additionalLight) + directSunScattering);
}`),t.code.add(w`vec4 getCloudData(vec3 rayDir, bool readOtherChannel)
{
vec4 cloudData = texture(cubeMap, rayDir);
float mu = dot(rayDir, vec3(0, 0, 1));
bool readChannels = readChannelsRG ^^ readOtherChannel;
if (readChannels) {
cloudData = vec4(vec3(cloudData.r), cloudData.g);
} else {
cloudData = vec4(vec3(cloudData.b), cloudData.a);
}
if (length(cloudData) == 0.0) {
return vec4(cloudData.rgb, 1.0);
}
return cloudData;
}`),t.code.add(w`vec4 renderCloudsNoFade(vec3 worldRay, vec3 cameraPosition)
{
vec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);
vec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));
vec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
vec4 cloudData = getCloudData(worldRayRotatedCorrected, false);
float totalTransmittance = clamp(cloudData.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);
if (length(cloudData.rgb) == 0.0) {
totalTransmittance = 1.0;
}
return vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), totalTransmittance);
}`),t.code.add(w`vec4 renderCloudsCrossFade(vec3 worldRay, vec3 cameraPosition)
{
vec3 intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPosition);
vec3 worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixClouds, normalize(intersectionPoint));
vec3 worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
vec4 cloudData = getCloudData(worldRayRotatedCorrected, false);
vec4 cloudColor = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);
intersectionPoint = intersectWithCloudLayer(normalize(worldRay), cameraPosition, anchorPositionCrossFade);
worldRayRotated = rotateDirectionToAnchorPoint(rotationMatrixCloudsCrossFade, normalize(intersectionPoint));
worldRayRotatedCorrected = correctForPlanetCurvature(worldRayRotated);
cloudData = getCloudData(worldRayRotatedCorrected, fadeTextureChannels);
vec4 cloudColorCrossFade = vec4(calculateCloudColor(cameraPosition, normalize(-worldRay), cloudData), cloudData.a);
cloudColor = mix(cloudColor, cloudColorCrossFade, crossFadeAnchorFactor);
float totalTransmittance = clamp(cloudColor.a * (1.0 - totalFadeInOut) + totalFadeInOut, 0.0 , 1.0);
if (length(cloudColor.rgb) == 0.0) {
totalTransmittance = 1.0;
}
return vec4(cloudColor.rgb, totalTransmittance);
}`),t.code.add(w`vec4 renderClouds(vec3 worldRay, vec3 cameraPosition)
{
return crossFade ? renderCloudsCrossFade(worldRay, cameraPosition) : renderCloudsNoFade(worldRay, cameraPosition);
}`)}var vi;(function(e){e[e.Occluded=0]="Occluded",e[e.NotOccluded=1]="NotOccluded",e[e.Both=2]="Both",e[e.COUNT=3]="COUNT"})(vi||(vi={}));function mh(e){e.include(oa),e.uniforms.add(new ke("geometryDepthTexture",(t,r)=>{var i;return(i=r.multipassGeometry.linearDepth)==null?void 0:i.getTexture()}),new Di("nearFar",(t,r)=>r.camera.nearFar)),e.code.add(w`bool geometryDepthTest(vec2 pos, float elementDepth) {
float geometryDepth = linearDepthFromTexture(geometryDepthTexture, pos, nearFar);
return (elementDepth < (geometryDepth - 1.0));
}`)}let pl=class{};function fl(e,t,r){return 2*Math.atan(Math.sqrt(t*t+r*r)*Math.tan(.5*e)/t)}function ml(e,t,r){return 2*Math.atan(Math.sqrt(t*t+r*r)*Math.tan(.5*e)/r)}function gl(e,t,r){return 2*Math.atan(t*Math.tan(.5*e)/Math.sqrt(t*t+r*r))}function _l(e,t,r){return 2*Math.atan(r*Math.tan(.5*e)/Math.sqrt(t*t+r*r))}var yi;let I=yi=class extends Ks{constructor(e){super(e),this._ray=hn(),this._viewport=fi(0,0,1,1),this._padding=fi(0,0,0,0),this._fov=55/180*Math.PI,this._nearFar=Xa(1,1e3),this._viewDirty=!0,this._viewMatrix=W(),this._viewProjectionDirty=!0,this._viewProjectionMatrix=W(),this._viewInverseTransposeMatrixDirty=!0,this._viewInverseTransposeMatrix=W(),this._frustumDirty=!0,this._frustum=Mn(),this._fullViewport=Ve(),this._pixelRatio=1,this.row=0,this.column=0,this._rows=1,this._columns=1,this._center=E(),this._up=E(),this.relativeElevation=0}get pixelRatio(){return this._pixelRatio}set pixelRatio(e){this._pixelRatio=e>0?e:1}get rows(){return this._rows}set rows(e){this._rows=Math.max(1,e)}get columns(){return this._columns}set columns(e){this._columns=Math.max(1,e)}get eye(){return this._ray.origin}set eye(e){this._compareAndSetView(e,this._ray.origin)}get center(){return this._center}set center(e){this._compareAndSetView(e,this._center,"_center")}get ray(){return ae(this._ray.direction,this.center,this.eye),this._ray}get up(){return this._up}set up(e){this._compareAndSetView(e,this._up,"_up")}get viewMatrix(){return this._ensureViewClean(),this._viewMatrix}set viewMatrix(e){it(this._viewMatrix,e),this.notifyChange("_viewMatrix"),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0}get viewForward(){return this._ensureViewClean(),Q(E(),-this._viewMatrix[2],-this._viewMatrix[6],-this._viewMatrix[10])}get viewUp(){return this._ensureViewClean(),Q(E(),this._viewMatrix[1],this._viewMatrix[5],this._viewMatrix[9])}get viewRight(){return this._ensureViewClean(),Q(E(),this._viewMatrix[0],this._viewMatrix[4],this._viewMatrix[8])}get nearFar(){return this._nearFar}get near(){return this._nearFar[0]}set near(e){this._nearFar[0]!==e&&(this._nearFar[0]=e,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_nearFar"))}get far(){return this._nearFar[1]}set far(e){this._nearFar[1]!==e&&(this._nearFar[1]=e,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_nearFar"))}get viewport(){return this._viewport}set viewport(e){this.x=e[0],this.y=e[1],this.width=e[2],this.height=e[3]}get screenViewport(){if(this.pixelRatio===1)return this._viewport;const e=Gi(Ve(),this._viewport,1/this.pixelRatio),t=this._get("screenViewport");return t&&Wi(e,t)?t:e}get screenPadding(){if(this.pixelRatio===1)return this._padding;const e=Gi(Ve(),this._padding,1/this.pixelRatio),t=this._get("screenPadding");return t&&Wi(e,t)?t:e}get x(){return this._viewport[0]}set x(e){e+=this._padding[z.LEFT],this._viewport[0]!==e&&(this._viewport[0]=e,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get y(){return this._viewport[1]}set y(e){e+=this._padding[z.BOTTOM],this._viewport[1]!==e&&(this._viewport[1]=e,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get width(){return this._viewport[2]}set width(e){this._viewport[2]!==e&&(this._viewport[2]=e,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get height(){return this._viewport[3]}set height(e){this._viewport[3]!==e&&(this._viewport[3]=e,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get fullWidth(){return this._viewport[2]+this._padding[z.RIGHT]+this._padding[z.LEFT]}set fullWidth(e){this.width=e-(this._padding[z.RIGHT]+this._padding[z.LEFT])}get fullHeight(){return this._viewport[3]+this._padding[z.TOP]+this._padding[z.BOTTOM]}set fullHeight(e){this.height=e-(this._padding[z.TOP]+this._padding[z.BOTTOM])}get fullViewport(){return this._fullViewport[0]=this._viewport[0]-this._padding[z.LEFT],this._fullViewport[1]=this._viewport[1]-this._padding[z.BOTTOM],this._fullViewport[2]=this.fullWidth,this._fullViewport[3]=this.fullHeight,this._fullViewport}get _aspect(){return this.width/this.height}get padding(){return this._padding}set padding(e){Ur(this._padding,e)||(this._viewport[0]+=e[z.LEFT]-this._padding[z.LEFT],this._viewport[1]+=e[z.BOTTOM]-this._padding[z.BOTTOM],this._viewport[2]-=e[z.RIGHT]+e[z.LEFT]-(this._padding[z.RIGHT]+this._padding[z.LEFT]),this._viewport[3]-=e[z.TOP]+e[z.BOTTOM]-(this._padding[z.TOP]+this._padding[z.BOTTOM]),or(this._padding,e),this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_padding"),this.notifyChange("_viewport"))}get viewProjectionMatrix(){return this._viewProjectionDirty&&(Be(this._viewProjectionMatrix,this.projectionMatrix,this.viewMatrix),this._viewProjectionDirty=!1),this._viewProjectionMatrix}get projectionMatrix(){const e=this.width,t=this.height,r=this.near*Math.tan(this.fovY/2)*2,i=r*this._aspect,s=r/this.rows,a=i/this.columns,o=-i/2+this.column*a,l=o+a,c=-r/2+this.row*s,n=c+s,d=Ka(W(),o*(1+2*this._padding[z.LEFT]/e),l*(1+2*this._padding[z.RIGHT]/e),c*(1+2*this._padding[z.BOTTOM]/t),n*(1+2*this._padding[z.TOP]/t),this.near,this.far),h=this._get("projectionMatrix");return h&&eo(h,d)?h:d}get inverseProjectionMatrix(){return kt(W(),this.projectionMatrix)||this._get("inverseProjectionMatrix")||W()}get fov(){return this._fov}set fov(e){this._fov=e,this._viewProjectionDirty=!0,this._frustumDirty=!0}get fovX(){return gl(this._fov,this.width,this.height)}set fovX(e){this._fov=fl(e,this.width,this.height),this._viewProjectionDirty=!0,this._frustumDirty=!0}get fovY(){return _l(this._fov,this.width,this.height)}set fovY(e){this._fov=ml(e,this.width,this.height),this._viewProjectionDirty=!0,this._frustumDirty=!0}get distance(){return jr(this.center,this.eye)}get frustum(){return this._recomputeFrustum(),this._frustum}get viewInverseTransposeMatrix(){return(this._viewInverseTransposeMatrixDirty||this._viewDirty)&&(kt(this._viewInverseTransposeMatrix,this.viewMatrix),ea(this._viewInverseTransposeMatrix,this._viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),this._viewInverseTransposeMatrix}depthNDCToWorld(e){const t=2*e-1;return 2*this.near*this.far/(this.far+this.near-t*(this.far-this.near))}get perRenderPixelRatio(){return Math.tan(this.fovX/2)/(this.width/2)}get perScreenPixelRatio(){return this.perRenderPixelRatio*this.pixelRatio}get aboveGround(){return this.relativeElevation!=null&&this.relativeElevation>=0}copyFrom(e){X(this._ray.origin,e.eye),this.center=e.center,this.up=e.up,or(this._viewport,e.viewport),this.notifyChange("_viewport"),or(this._padding,e.padding),this.notifyChange("_padding"),Ni(this._nearFar,e.nearFar),this.notifyChange("_nearFar"),this._fov=e.fov,this.row=e.row,this.column=e.column,this.rows=e.rows,this.columns=e.columns,this.relativeElevation=e.relativeElevation;const t=e;return this._viewDirty=t._viewDirty,this._viewDirty||(it(this._viewMatrix,e.viewMatrix),this.notifyChange("_viewMatrix")),this._viewProjectionDirty=!0,this._frustumDirty=t._frustumDirty,this._frustumDirty||(En(this._frustum,e.frustum),this._frustumDirty=!1),t._viewInverseTransposeMatrixDirty?this._viewInverseTransposeMatrixDirty=!0:(it(this._viewInverseTransposeMatrix,e.viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),or(this._fullViewport,e.fullViewport),this.pixelRatio=e.pixelRatio,this}copyViewFrom(e){this.eye=e.eye,this.center=e.center,this.up=e.up}clone(){return new yi().copyFrom(this)}equals(e){return St(this.eye,e.eye)&&St(this.center,e.center)&&St(this.up,e.up)&&Ur(this._viewport,e.viewport)&&Ur(this._padding,e.padding)&&An(this.nearFar,e.nearFar)&&this._fov===e.fov&&this.pixelRatio===e.pixelRatio&&this.relativeElevation===e.relativeElevation&&this.row===e.row&&this.column===e.column&&this.rows===e.rows&&this.columns===e.columns}almostEquals(e){const t=Math.max(1,1/this.pixelRatio,1/e.pixelRatio);if(Math.abs(e.fov-this._fov)>=.001||Bi(e.screenPadding,this.screenPadding)>=t||Bi(this.screenViewport,e.screenViewport)>=t||this.row!==e.row||this.column!==e.column||this.rows!==e.rows||this.columns!==e.columns)return!1;ki(oe,e.eye,e.center),ki(Jr,this.eye,this.center);const r=Lt(oe,Jr),i=qi(oe),s=qi(Jr),a=5e-4;return r*r>=(1-1e-10)*i*s&&to(e.eye,this.eye)<Math.max(i,s)*a*a}computeRenderPixelSizeAt(e){return this.computeRenderPixelSizeAtDist(this._viewDirectionDistance(e))}computeRenderPixelSizeAtDist(e){return e*this.perRenderPixelRatio}computeScreenPixelSizeAt(e){return this.computeScreenPixelSizeAtDist(this._viewDirectionDistance(e))}_viewDirectionDistance(e){return Math.abs(ln(this.viewForward,ae(oe,e,this.eye)))}computeScreenPixelSizeAtDist(e){return e*this.perScreenPixelRatio}computeDistanceFromRadius(e,t){return e/Math.tan(Math.min(this.fovX,this.fovY)/(2*(t||1)))}getScreenCenter(e=ro()){return e[0]=(this.padding[z.LEFT]+this.width/2)/this.pixelRatio,e[1]=(this.padding[z.TOP]+this.height/2)/this.pixelRatio,e}getRenderCenter(e,t=.5,r=.5){return e[0]=this.padding[z.LEFT]+this.width*t,e[1]=this.padding[z.BOTTOM]+this.height*r,e[2]=.5,e}setGLViewport(e){const t=this.viewport,r=this.padding;e.setViewport(t[0]-r[3],t[1]-r[2],t[2]+r[1]+r[3],t[3]+r[0]+r[2])}applyProjection(e,t){e!==L&&X(L,e),L[3]=1,Ht(L,L,this.projectionMatrix);const r=Math.abs(L[3]);se(L,L,1/r);const i=this.fullViewport;t[0]=Gt(0,i[0]+i[2],.5+.5*L[0]),t[1]=Gt(0,i[1]+i[3],.5+.5*L[1]),t[2]=.5*(L[2]+1),t[3]=r}unapplyProjection(e,t){const r=this.fullViewport;L[0]=(e[0]/(r[0]+r[2])*2-1)*e[3],L[1]=(e[1]/(r[1]+r[3])*2-1)*e[3],L[2]=(2*e[2]-1)*e[3],L[3]=e[3],this.inverseProjectionMatrix!=null&&(Ht(L,L,this.inverseProjectionMatrix),t[0]=L[0],t[1]=L[1],t[2]=L[2])}projectToScreen(e,t){return this.projectToRenderScreen(e,Yr),this.renderToScreen(Yr,t),t}projectToRenderScreen(e,t){if(L[0]=e[0],L[1]=e[1],L[2]=e[2],L[3]=1,Ht(L,L,this.viewProjectionMatrix),L[3]===0)return null;const r=L;se(r,r,1/Math.abs(L[3]));const i=this.fullViewport,s=Gt(0,i[0]+i[2],.5+.5*r[0]),a=Gt(0,i[1]+i[3],.5+.5*r[1]);return"x"in t?(t.x=s,t.y=a):(t[0]=s,t[1]=a,t.length>2&&(t[2]=.5*(r[2]+1))),t}unprojectFromScreen(e,t){return this.unprojectFromRenderScreen(this.screenToRender(e,Yr),t)}unprojectFromRenderScreen(e,t){if(Be(hr,this.projectionMatrix,this.viewMatrix),!kt(hr,hr))return null;const r=this.fullViewport;return L[0]=2*(e[0]-r[0])/r[2]-1,L[1]=2*(e[1]-r[1])/r[3]-1,L[2]=2*e[2]-1,L[3]=1,Ht(L,L,hr),L[3]===0?null:(t[0]=L[0]/L[3],t[1]=L[1]/L[3],t[2]=L[2]/L[3],t)}constrainWindowSize(e,t,r,i){const s=e*this.pixelRatio,a=t*this.pixelRatio,o=Math.max(s-r/2,0),l=Math.max(this.fullHeight-a-i/2,0),c=-Math.min(s-r/2,0),n=-Math.min(this.fullHeight-a-i/2,0),d=r-c- -Math.min(this.fullWidth-s-r/2,0),h=i-n- -Math.min(a-i/2,0);return[Math.round(o),Math.round(l),Math.round(d),Math.round(h)]}computeUp(e){e===Li.Global?this._computeUpGlobal():this._computeUpLocal()}screenToRender(e,t){const r=e[0]*this.pixelRatio,i=this.fullHeight-e[1]*this.pixelRatio;return t[0]=r,t[1]=i,t}renderToScreen(e,t){const r=e[0]/this.pixelRatio,i=(this.fullHeight-e[1])/this.pixelRatio;t[0]=r,t[1]=i}_computeUpGlobal(){ae(oe,this.center,this.eye);const e=Jt(this.center);e<1?(Q(this._up,0,0,1),this._markViewDirty(),this.notifyChange("_up")):Math.abs(Lt(oe,this.center))>.9999*Jt(oe)*e||(Le(this._up,oe,this.center),Le(this._up,this._up,oe),re(this._up,this._up),this.notifyChange("_up"),this._markViewDirty())}_computeUpLocal(){io(oe,this.eye,this.center),Math.abs(oe[2])<=.9999&&(se(oe,oe,oe[2]),Q(this._up,-oe[0],-oe[1],1-oe[2]),re(this._up,this._up),this.notifyChange("_up"),this._markViewDirty())}_compareAndSetView(e,t,r=""){typeof e[0]=="number"&&isFinite(e[0])&&typeof e[1]=="number"&&isFinite(e[1])&&typeof e[2]=="number"&&isFinite(e[2])?St(e,t)||(X(t,e),this._markViewDirty(),r.length&&this.notifyChange(r)):zr.getLogger("esri.views.3d.webgl-engine.lib.Camera").warn("Camera vector contains invalid number, ignoring value")}_markViewDirty(){this._viewDirty=!0,this._frustumDirty=!0,this._viewProjectionDirty=!0}_recomputeFrustum(){this._frustumDirty&&($n(this.viewMatrix,this.projectionMatrix,this._frustum),this._frustumDirty=!1)}_ensureViewClean(){this._viewDirty&&(ta(this._viewMatrix,this.eye,this.center,this.up),this.notifyChange("_viewMatrix"),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0)}};m([b()],I.prototype,"_viewport",void 0),m([b()],I.prototype,"_padding",void 0),m([b()],I.prototype,"_fov",void 0),m([b()],I.prototype,"_nearFar",void 0),m([b()],I.prototype,"_viewDirty",void 0),m([b()],I.prototype,"_viewMatrix",void 0),m([b()],I.prototype,"_pixelRatio",void 0),m([b()],I.prototype,"pixelRatio",null),m([b()],I.prototype,"row",void 0),m([b()],I.prototype,"column",void 0),m([b()],I.prototype,"_rows",void 0),m([b()],I.prototype,"rows",null),m([b()],I.prototype,"_columns",void 0),m([b()],I.prototype,"columns",null),m([b()],I.prototype,"eye",null),m([b()],I.prototype,"center",null),m([b()],I.prototype,"_center",void 0),m([b()],I.prototype,"up",null),m([b()],I.prototype,"_up",void 0),m([b({readOnly:!0})],I.prototype,"viewForward",null),m([b({readOnly:!0})],I.prototype,"viewUp",null),m([b({readOnly:!0})],I.prototype,"viewRight",null),m([b({readOnly:!0})],I.prototype,"nearFar",null),m([b()],I.prototype,"near",null),m([b()],I.prototype,"far",null),m([b()],I.prototype,"viewport",null),m([b({readOnly:!0})],I.prototype,"screenViewport",null),m([b({readOnly:!0})],I.prototype,"screenPadding",null),m([b()],I.prototype,"x",null),m([b()],I.prototype,"y",null),m([b()],I.prototype,"width",null),m([b()],I.prototype,"height",null),m([b()],I.prototype,"fullWidth",null),m([b()],I.prototype,"fullHeight",null),m([b({readOnly:!0})],I.prototype,"_aspect",null),m([b()],I.prototype,"padding",null),m([b({readOnly:!0})],I.prototype,"projectionMatrix",null),m([b({readOnly:!0})],I.prototype,"inverseProjectionMatrix",null),m([b()],I.prototype,"fov",null),m([b()],I.prototype,"fovX",null),m([b()],I.prototype,"fovY",null),I=yi=m([tr("esri.views.3d.webgl-engine.lib.Camera")],I);const L=Ve(),hr=W(),oe=E(),Jr=E(),Yr=Ke();var z;(function(e){e[e.TOP=0]="TOP",e[e.RIGHT=1]="RIGHT",e[e.BOTTOM=2]="BOTTOM",e[e.LEFT=3]="LEFT"})(z||(z={}));let vl=class{constructor(t,r){this.shadowMap=t,this.slicePlane=r,this.slot=ie.OPAQUE_MATERIAL,this.hasOccludees=!1,this.enableFillLights=!0,this.transparencyPassType=Ue.NONE,this.alignPixelEnabled=!1,this.decorations=In.ON,this.overlayStretch=1,this._camera=new I,this._inverseViewport=k(),this.oldLighting=new Br,this.newLighting=new Br,this._fadedLighting=new Br,this._lighting=this.newLighting,this.ssr=new yl,this.multipassEnabled=!1,this.multipassTerrain=new Ro,this.multipassGeometry=new pl,this.hudRenderStyle=vi.Occluded,this.cloudsFade=new al}get camera(){return this._camera}set camera(t){this._camera=t,this._inverseViewport[0]=1/t.fullViewport[2],this._inverseViewport[1]=1/t.fullViewport[3]}get inverseViewport(){return this._inverseViewport}get lighting(){return this._lighting}get weatherFading(){return this._lighting===this._fadedLighting}fadeLighting(t){const{oldLighting:r,newLighting:i}=this;t>=1?this._lighting=i:(this._fadedLighting.lerpLighting(r,i,t),this._lighting=this._fadedLighting)}},yl=class{constructor(){this.fadeFactor=1,this.reprojectionMatrix=W()}};var wi;(function(e){function t(o,l){const c=o[l],n=o[l+1],d=o[l+2];return Math.sqrt(c*c+n*n+d*d)}function r(o,l){const c=o[l],n=o[l+1],d=o[l+2],h=1/Math.sqrt(c*c+n*n+d*d);o[l]*=h,o[l+1]*=h,o[l+2]*=h}function i(o,l,c){o[l]*=c,o[l+1]*=c,o[l+2]*=c}function s(o,l,c,n,d,h=l){(d=d||o)[h]=o[l]+c[n],d[h+1]=o[l+1]+c[n+1],d[h+2]=o[l+2]+c[n+2]}function a(o,l,c,n,d,h=l){(d=d||o)[h]=o[l]-c[n],d[h+1]=o[l+1]-c[n+1],d[h+2]=o[l+2]-c[n+2]}e.length=t,e.normalize=r,e.scale=i,e.add=s,e.subtract=a})(wi||(wi={}));const pt=wi,Xr=[[-.5,-.5,.5],[.5,-.5,.5],[.5,.5,.5],[-.5,.5,.5],[-.5,-.5,-.5],[.5,-.5,-.5],[.5,.5,-.5],[-.5,.5,-.5]],wl=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],xl=[0,0,1,0,1,1,0,1],Cl=[0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5],wa=new Array(36);for(let e=0;e<6;e++)for(let t=0;t<6;t++)wa[6*e+t]=e;const Xe=new Array(36);for(let e=0;e<6;e++)Xe[6*e]=0,Xe[6*e+1]=1,Xe[6*e+2]=2,Xe[6*e+3]=2,Xe[6*e+4]=3,Xe[6*e+5]=0;function yh(e,t){Array.isArray(t)||(t=[t,t,t]);const r=new Array(24);for(let i=0;i<8;i++)r[3*i]=Xr[i][0]*t[0],r[3*i+1]=Xr[i][1]*t[1],r[3*i+2]=Xr[i][2]*t[2];return new we(e,[[y.POSITION,new j(r,Cl,3,!0)],[y.NORMAL,new j(wl,wa,3)],[y.UV0,new j(xl,Xe,2)]])}const Kr=[[-.5,0,-.5],[.5,0,-.5],[.5,0,.5],[-.5,0,.5],[0,-.5,0],[0,.5,0]],Sl=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],Tl=[5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0],Rl=[0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7];function wh(e,t){Array.isArray(t)||(t=[t,t,t]);const r=new Array(18);for(let i=0;i<6;i++)r[3*i]=Kr[i][0]*t[0],r[3*i+1]=Kr[i][1]*t[1],r[3*i+2]=Kr[i][2]*t[2];return new we(e,[[y.POSITION,new j(r,Tl,3,!0)],[y.NORMAL,new j(Sl,Rl,3)]])}const Cr=J(-.5,0,-.5),Sr=J(.5,0,-.5),Tr=J(0,0,.5),Rr=J(0,.5,0),ft=Re(),mt=Re(),$t=Re(),It=Re(),Pt=Re();ae(ft,Cr,Rr),ae(mt,Cr,Sr),Le($t,ft,mt),re($t,$t),ae(ft,Sr,Rr),ae(mt,Sr,Tr),Le(It,ft,mt),re(It,It),ae(ft,Tr,Rr),ae(mt,Tr,Cr),Le(Pt,ft,mt),re(Pt,Pt);const ei=[Cr,Sr,Tr,Rr],Ol=[0,-1,0,$t[0],$t[1],$t[2],It[0],It[1],It[2],Pt[0],Pt[1],Pt[2]],bl=[0,1,2,3,1,0,3,2,1,3,0,2],Al=[0,0,0,1,1,1,2,2,2,3,3,3];function xh(e,t){Array.isArray(t)||(t=[t,t,t]);const r=new Array(12);for(let i=0;i<4;i++)r[3*i]=ei[i][0]*t[0],r[3*i+1]=ei[i][1]*t[1],r[3*i+2]=ei[i][2]*t[2];return new we(e,[[y.POSITION,new j(r,bl,3,!0)],[y.NORMAL,new j(Ol,Al,3)]])}function Ch(e,t,r,i,s={uv:!0}){const a=-Math.PI,o=2*Math.PI,l=-Math.PI/2,c=Math.PI,n=Math.max(3,Math.floor(r)),d=Math.max(2,Math.floor(i)),h=(n+1)*(d+1),p=De(3*h),u=De(3*h),f=De(2*h),_=[];let x=0;for(let v=0;v<=d;v++){const O=[],C=v/d,A=l+C*c,g=Math.cos(A);for(let U=0;U<=n;U++){const V=U/n,D=a+V*o,ce=Math.cos(D)*g,N=Math.sin(A),Fe=-Math.sin(D)*g;p[3*x]=ce*t,p[3*x+1]=N*t,p[3*x+2]=Fe*t,u[3*x]=ce,u[3*x+1]=N,u[3*x+2]=Fe,f[2*x]=V,f[2*x+1]=C,O.push(x),++x}_.push(O)}const T=new Array;for(let v=0;v<d;v++)for(let O=0;O<n;O++){const C=_[v][O],A=_[v][O+1],g=_[v+1][O+1],U=_[v+1][O];v===0?(T.push(C),T.push(g),T.push(U)):v===d-1?(T.push(C),T.push(A),T.push(g)):(T.push(C),T.push(A),T.push(g),T.push(g),T.push(U),T.push(C))}const S=[[y.POSITION,new j(p,T,3,!0)],[y.NORMAL,new j(u,T,3,!0)]];return s.uv&&S.push([y.UV0,new j(f,T,2,!0)]),s.offset&&(S[0][0]=y.OFFSET,S.push([y.POSITION,new j(Float64Array.from(s.offset),ca(T.length),3,!0)])),new we(e,S)}function Sh(e,t,r,i){const s=Dl(t,r,i);return new we(e,s)}function Dl(e,t,r){const i=e;let s,a;if(r)s=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],a=[0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1];else{const n=i*(1+Math.sqrt(5))/2;s=[-i,n,0,i,n,0,-i,-n,0,i,-n,0,0,-i,n,0,i,n,0,-i,-n,0,i,-n,n,0,-i,n,0,i,-n,0,-i,-n,0,i],a=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1]}for(let n=0;n<s.length;n+=3)pt.scale(s,n,e/pt.length(s,n));let o={};function l(n,d){n>d&&([n,d]=[d,n]);const h=n.toString()+"."+d.toString();if(o[h])return o[h];let p=s.length;return s.length+=3,pt.add(s,3*n,s,3*d,s,p),pt.scale(s,p,e/pt.length(s,p)),p/=3,o[h]=p,p}for(let n=0;n<t;n++){const d=a.length,h=new Array(4*d);for(let p=0;p<d;p+=3){const u=a[p],f=a[p+1],_=a[p+2],x=l(u,f),T=l(f,_),S=l(_,u),v=4*p;h[v]=u,h[v+1]=x,h[v+2]=S,h[v+3]=f,h[v+4]=T,h[v+5]=x,h[v+6]=_,h[v+7]=S,h[v+8]=T,h[v+9]=x,h[v+10]=T,h[v+11]=S}a=h,o={}}const c=ts(s);for(let n=0;n<c.length;n+=3)pt.normalize(c,n);return[[y.POSITION,new j(ts(s),a,3,!0)],[y.NORMAL,new j(c,a,3,!0)]]}function Th(e,t,r,i,s,a,o,l,c=null){const n=r?Zi(r):E(),d=t?Zi(t):st(0,0,1);o??(o=k());const h=i?[255*i[0],255*i[1],255*i[2],i.length>3?255*i[3]:255]:[255,255,255,255],p=s!=null&&s.length===2?s:[1,1],u=ca(1),f=[[y.POSITION,new j(n,u,3,!0)],[y.NORMAL,new j(d,u,3,!0)],[y.UV0,new j(o,u,o.length)],[y.COLOR,new j(h,u,4,!0)],[y.SIZE,new j(p,u,2)]];if(a!=null&&(a=[a[0],a[1],a[2],a[3]],f.push([y.CENTEROFFSETANDDISTANCE,new j(a,u,4)])),l){const _=[l[0],l[1],l[2],l[3]];f.push([y.FEATUREATTRIBUTE,new j(_,u,4)])}return new we(e,f,null,Nt.Point,c)}const Ml=[[-1,-1,0],[1,-1,0],[1,1,0],[-1,1,0]];function Rh(e,t=Ml){const r=new Array(12);for(let n=0;n<4;n++)for(let d=0;d<3;d++)r[3*n+d]=t[n][d];const i=[0,1,2,2,3,0],s=[0,0,1],a=[0,0,0,0,0,0],o=[0,0,1,0,1,1,0,1],l=[255,255,255,255],c=[[y.POSITION,new j(r,i,3,!0)],[y.NORMAL,new j(s,a,3,!0)],[y.UV0,new j(o,i,2,!0)],[y.COLOR,new j(l,a,4,!0)]];return new we(e,c)}function Oh(e,t,r,i,s,a=!0,o=!0){let l=0;const c=r,n=t;let d=J(0,l,0),h=J(0,l+n,0),p=J(0,-1,0),u=J(0,1,0);s&&(l=n,h=J(0,0,0),d=J(0,l,0),p=J(0,1,0),u=J(0,-1,0));const f=[h,d],_=[p,u],x=i+2,T=Math.sqrt(n*n+c*c);if(s)for(let g=i-1;g>=0;g--){const U=g*(2*Math.PI/i),V=J(Math.cos(U)*c,l,Math.sin(U)*c);f.push(V);const D=J(n*Math.cos(U)/T,-c/T,n*Math.sin(U)/T);_.push(D)}else for(let g=0;g<i;g++){const U=g*(2*Math.PI/i),V=J(Math.cos(U)*c,l,Math.sin(U)*c);f.push(V);const D=J(n*Math.cos(U)/T,c/T,n*Math.sin(U)/T);_.push(D)}const S=new Array,v=new Array;if(a){for(let g=3;g<f.length;g++)S.push(1),S.push(g-1),S.push(g),v.push(0),v.push(0),v.push(0);S.push(f.length-1),S.push(2),S.push(1),v.push(0),v.push(0),v.push(0)}if(o){for(let g=3;g<f.length;g++)S.push(g),S.push(g-1),S.push(0),v.push(g),v.push(g-1),v.push(1);S.push(0),S.push(2),S.push(f.length-1),v.push(1),v.push(2),v.push(_.length-1)}const O=De(3*x);for(let g=0;g<x;g++)O[3*g]=f[g][0],O[3*g+1]=f[g][1],O[3*g+2]=f[g][2];const C=De(3*x);for(let g=0;g<x;g++)C[3*g]=_[g][0],C[3*g+1]=_[g][1],C[3*g+2]=_[g][2];const A=[[y.POSITION,new j(O,S,3,!0)],[y.NORMAL,new j(C,v,3,!0)]];return new we(e,A)}function bh(e,t,r,i,s,a,o){const l=s?es(s):J(1,0,0),c=a?es(a):J(0,0,0);o??(o=!0);const n=Re();re(n,l);const d=Re();se(d,n,Math.abs(t));const h=Re();se(h,d,-.5),le(h,h,c);const p=J(0,1,0);Math.abs(1-Lt(n,p))<.2&&Q(p,0,0,1);const u=Re();Le(u,n,p),re(u,u),Le(p,u,n);const f=2*i+(o?2:0),_=i+(o?2:0),x=De(3*f),T=De(3*_),S=De(2*f),v=new Array(3*i*(o?4:2)),O=new Array(3*i*(o?4:2));o&&(x[3*(f-2)]=h[0],x[3*(f-2)+1]=h[1],x[3*(f-2)+2]=h[2],S[2*(f-2)]=0,S[2*(f-2)+1]=0,x[3*(f-1)]=x[3*(f-2)]+d[0],x[3*(f-1)+1]=x[3*(f-2)+1]+d[1],x[3*(f-1)+2]=x[3*(f-2)+2]+d[2],S[2*(f-1)]=1,S[2*(f-1)+1]=1,T[3*(_-2)]=-n[0],T[3*(_-2)+1]=-n[1],T[3*(_-2)+2]=-n[2],T[3*(_-1)]=n[0],T[3*(_-1)+1]=n[1],T[3*(_-1)+2]=n[2]);const C=(D,ce,N)=>{v[D]=ce,O[D]=N};let A=0;const g=Re(),U=Re();for(let D=0;D<i;D++){const ce=D*(2*Math.PI/i);se(g,p,Math.sin(ce)),se(U,u,Math.cos(ce)),le(g,g,U),T[3*D]=g[0],T[3*D+1]=g[1],T[3*D+2]=g[2],se(g,g,r),le(g,g,h),x[3*D]=g[0],x[3*D+1]=g[1],x[3*D+2]=g[2],S[2*D]=D/i,S[2*D+1]=0,x[3*(D+i)]=x[3*D]+d[0],x[3*(D+i)+1]=x[3*D+1]+d[1],x[3*(D+i)+2]=x[3*D+2]+d[2],S[2*(D+i)]=D/i,S[2*D+1]=1;const N=(D+1)%i;C(A++,D,D),C(A++,D+i,D),C(A++,N,N),C(A++,N,N),C(A++,D+i,D),C(A++,N+i,N)}if(o){for(let D=0;D<i;D++){const ce=(D+1)%i;C(A++,f-2,_-2),C(A++,D,_-2),C(A++,ce,_-2)}for(let D=0;D<i;D++){const ce=(D+1)%i;C(A++,D+i,_-1),C(A++,f-1,_-1),C(A++,ce+i,_-1)}}const V=[[y.POSITION,new j(x,v,3,!0)],[y.NORMAL,new j(T,O,3,!0)],[y.UV0,new j(S,v,2,!0)]];return new we(e,V)}function Ah(e,t,r,i,s,a){i=i||10,s=s==null||s,pe(t.length>1);const o=[[0,0,0]],l=[],c=[];for(let n=0;n<i;n++){l.push([0,-n-1,-(n+1)%i-1]);const d=n/i*2*Math.PI;c.push([Math.cos(d)*r,Math.sin(d)*r])}return El(e,c,t,o,l,s,a)}function El(e,t,r,i,s,a,o=J(0,0,0)){const l=t.length,c=De(r.length*l*3+(6*i.length||0)),n=De(r.length*l*3+(i?6:0)),d=new Array,h=new Array;let p=0,u=0;const f=E(),_=E(),x=E(),T=E(),S=E(),v=E(),O=E(),C=E(),A=E(),g=E(),U=E(),V=E(),D=E(),ce=rr();Q(A,0,1,0),ae(_,r[1],r[0]),re(_,_),a?(le(C,r[0],o),re(x,C)):Q(x,0,0,1),ws(_,x,A,A,S,x,xs),X(T,x),X(V,S);for(let $=0;$<i.length;$++)se(v,S,i[$][0]),se(C,x,i[$][2]),le(v,v,C),le(v,v,r[0]),c[p++]=v[0],c[p++]=v[1],c[p++]=v[2];n[u++]=-_[0],n[u++]=-_[1],n[u++]=-_[2];for(let $=0;$<s.length;$++)d.push(s[$][0]>0?s[$][0]:-s[$][0]-1+i.length),d.push(s[$][1]>0?s[$][1]:-s[$][1]-1+i.length),d.push(s[$][2]>0?s[$][2]:-s[$][2]-1+i.length),h.push(0),h.push(0),h.push(0);let N=i.length;const Fe=i.length-1;for(let $=0;$<r.length;$++){let B=!1;$>0&&(X(f,_),$<r.length-1?(ae(_,r[$+1],r[$]),re(_,_)):B=!0,le(g,f,_),re(g,g),le(U,r[$-1],T),cn(r[$],g,ce),dn(ce,un(U,f),C)?(ae(C,C,r[$]),re(x,C),Le(S,g,x),re(S,S)):ws(g,T,V,A,S,x,xs),X(T,x),X(V,S)),a&&(le(C,r[$],o),re(D,C));for(let K=0;K<l;K++)if(se(v,S,t[K][0]),se(C,x,t[K][1]),le(v,v,C),re(O,v),n[u++]=O[0],n[u++]=O[1],n[u++]=O[2],le(v,v,r[$]),c[p++]=v[0],c[p++]=v[1],c[p++]=v[2],!B){const ge=(K+1)%l;d.push(N+K),d.push(N+l+K),d.push(N+ge),d.push(N+ge),d.push(N+l+K),d.push(N+l+ge);for(let je=0;je<6;je++){const lt=d.length-6;h.push(d[lt+je]-Fe)}}N+=l}const jt=r[r.length-1];for(let $=0;$<i.length;$++)se(v,S,i[$][0]),se(C,x,i[$][1]),le(v,v,C),le(v,v,jt),c[p++]=v[0],c[p++]=v[1],c[p++]=v[2];const Ne=u/3;n[u++]=_[0],n[u++]=_[1],n[u++]=_[2];const nt=N-l;for(let $=0;$<s.length;$++)d.push(s[$][0]>=0?N+s[$][0]:-s[$][0]-1+nt),d.push(s[$][2]>=0?N+s[$][2]:-s[$][2]-1+nt),d.push(s[$][1]>=0?N+s[$][1]:-s[$][1]-1+nt),h.push(Ne),h.push(Ne),h.push(Ne);const sr=[[y.POSITION,new j(c,d,3,!0)],[y.NORMAL,new j(n,h,3,!0)]];return new we(e,sr)}function Dh(e,t,r,i){pe(t.length>1,"createPolylineGeometry(): polyline needs at least 2 points"),pe(t[0].length===3,"createPolylineGeometry(): malformed vertex"),pe(r==null||r.length===t.length,"createPolylineGeometry: need same number of points and normals"),pe(r==null||r[0].length===3,"createPolylineGeometry(): malformed normal");const s=To(3*t.length),a=new Array(2*(t.length-1));let o=0,l=0;for(let n=0;n<t.length;n++){for(let d=0;d<3;d++)s[o++]=t[n][d];n>0&&(a[l++]=n-1,a[l++]=n)}const c=[[y.POSITION,new j(s,a,3,!0)]];if(r){const n=De(3*r.length);let d=0;for(let h=0;h<t.length;h++)for(let p=0;p<3;p++)n[d++]=r[h][p];c.push([y.NORMAL,new j(n,a,3,!0)])}return i&&c.push([y.COLOR,new j(i,nn(i.length/4),4)]),new we(e,c,null,Nt.Line)}function Mh(e,t,r,i,s,a=0){const o=new Array(18),l=[[-r,a,s/2],[i,a,s/2],[0,t+a,s/2],[-r,a,-s/2],[i,a,-s/2],[0,t+a,-s/2]],c=[0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5];for(let n=0;n<6;n++)o[3*n]=l[n][0],o[3*n+1]=l[n][1],o[3*n+2]=l[n][2];return new we(e,[[y.POSITION,new j(o,c,3,!0)]])}function Eh(e,t){const r=e.getMutableAttribute(y.POSITION).data;for(let i=0;i<r.length;i+=3){const s=r[i],a=r[i+1],o=r[i+2];Q(gt,s,a,o),ye(gt,gt,t),r[i]=gt[0],r[i+1]=gt[1],r[i+2]=gt[2]}}function $h(e,t=e){const r=e.attributes,i=r.get(y.POSITION).data,s=r.get(y.NORMAL).data;if(s){const a=t.getMutableAttribute(y.NORMAL).data;for(let o=0;o<s.length;o+=3){const l=s[o+1];a[o+1]=-s[o+2],a[o+2]=l}}if(i){const a=t.getMutableAttribute(y.POSITION).data;for(let o=0;o<i.length;o+=3){const l=i[o+1];a[o+1]=-i[o+2],a[o+2]=l}}}function ti(e,t,r,i,s){return!(Math.abs(Lt(t,e))>s)&&(Le(r,e,t),re(r,r),Le(i,r,e),re(i,i),!0)}function ws(e,t,r,i,s,a,o){return ti(e,t,s,a,o)||ti(e,r,s,a,o)||ti(e,i,s,a,o)}const xs=.99619469809,gt=E();function Ih(e,t,r,i,s,a,o,l,c,n,d){const h=zl[d.mode];let p,u,f=0;if(mi(e,t,r,i,c.spatialReference,s,l))return h.requiresAlignment(d)?(f=h.applyElevationAlignmentBuffer(i,s,a,o,l,c,n,d),p=a,u=o):(p=i,u=s),mi(p,c.spatialReference,u,a,n.spatialReference,o,l)?f:void 0}function xa(e,t,r,i,s){const a=(yn(e)?e.z:wn(e)?e.array[e.offset+2]:e[2])||0;switch(r.mode){case"on-the-ground":{const o=cr(t,e,"ground")??0;return s.verticalDistanceToGround=0,s.sampledElevation=o,void(s.z=o)}case"relative-to-ground":{const o=cr(t,e,"ground")??0,l=r.geometryZWithOffset(a,i);return s.verticalDistanceToGround=l,s.sampledElevation=o,void(s.z=l+o)}case"relative-to-scene":{const o=cr(t,e,"scene")??0,l=r.geometryZWithOffset(a,i);return s.verticalDistanceToGround=l,s.sampledElevation=o,void(s.z=l+o)}case"absolute-height":{const o=r.geometryZWithOffset(a,i),l=cr(t,e,"ground")??0;return s.verticalDistanceToGround=o-l,s.sampledElevation=l,void(s.z=o)}default:return void(s.z=0)}}function Ph(e,t,r,i){return xa(e,t,r,i,bt),bt.z}function Lh(e,t,r){return t==null||r==null?e.definedChanged:t==="on-the-ground"&&r==="on-the-ground"?e.staysOnTheGround:t===r||t!=="on-the-ground"&&r!=="on-the-ground"?xi.UPDATE:e.onTheGroundChanged}function Fh(e){return e==="relative-to-ground"||e==="relative-to-scene"}function Nh(e){return e!=="absolute-height"}function jh(e,t,r,i,s){xa(t,r,s,i,bt),$l(e,bt.verticalDistanceToGround);const a=bt.sampledElevation,o=it(Vl,e.transformation);return ur[0]=t.x,ur[1]=t.y,ur[2]=bt.z,vn(t.spatialReference,ur,o,i.spatialReference)?e.transformation=o:console.warn("Could not locate symbol object properly, it might be misplaced"),a}function $l(e,t){for(let r=0;r<e.geometries.length;++r){const i=e.geometries[r].getMutableAttribute(y.CENTEROFFSETANDDISTANCE);i&&i.data[3]!==t&&(i.data[3]=t,e.geometryVertexAttributeUpdated(e.geometries[r],y.CENTEROFFSETANDDISTANCE))}}function Il(e,t,r,i,s,a){let o=0;const l=a.spatialReference;t*=3,i*=3;for(let c=0;c<s;++c){const n=e[t],d=e[t+1],h=e[t+2],p=a.getElevation(n,d,h,l,"ground")??0;o+=p,r[i]=n,r[i+1]=d,r[i+2]=p,t+=3,i+=3}return o/s}function Pl(e,t,r,i,s,a,o,l){let c=0;const n=l.calculateOffsetRenderUnits(o),d=l.featureExpressionInfoContext,h=a.spatialReference;t*=3,i*=3;for(let p=0;p<s;++p){const u=e[t],f=e[t+1],_=e[t+2],x=a.getElevation(u,f,_,h,"ground")??0;c+=x,r[i]=u,r[i+1]=f,r[i+2]=d==null?_+x+n:x+n,t+=3,i+=3}return c/s}function Ll(e,t,r,i,s,a,o,l){let c=0;const n=l.calculateOffsetRenderUnits(o),d=l.featureExpressionInfoContext,h=a.spatialReference;t*=3,i*=3;for(let p=0;p<s;++p){const u=e[t],f=e[t+1],_=e[t+2],x=a.getElevation(u,f,_,h,"scene")??0;c+=x,r[i]=u,r[i+1]=f,r[i+2]=d==null?_+x+n:x+n,t+=3,i+=3}return c/s}function Fl(e){const t=e.meterUnitOffset,r=e.featureExpressionInfoContext;return t!==0||r!=null}function Nl(e,t,r,i,s,a,o,l){const c=l.calculateOffsetRenderUnits(o),n=l.featureExpressionInfoContext;t*=3,i*=3;for(let d=0;d<s;++d){const h=e[t],p=e[t+1],u=e[t+2];r[i]=h,r[i+1]=p,r[i+2]=n==null?u+c:c,t+=3,i+=3}return 0}let jl=class{constructor(){this.verticalDistanceToGround=0,this.sampledElevation=0,this.z=0}};var xi;(function(e){e[e.NONE=0]="NONE",e[e.UPDATE=1]="UPDATE",e[e.RECREATE=2]="RECREATE"})(xi||(xi={}));const zl={"absolute-height":{applyElevationAlignmentBuffer:Nl,requiresAlignment:Fl},"on-the-ground":{applyElevationAlignmentBuffer:Il,requiresAlignment:()=>!0},"relative-to-ground":{applyElevationAlignmentBuffer:Pl,requiresAlignment:()=>!0},"relative-to-scene":{applyElevationAlignmentBuffer:Ll,requiresAlignment:()=>!0}},Vl=W(),bt=new jl,ur=E(),Ul=()=>zr.getLogger("esri.views.3d.layers.graphics.featureExpressionInfoUtils");function Hl(e){return{cachedResult:e.cachedResult,arcade:e.arcade?{func:e.arcade.func,context:e.arcade.modules.arcadeUtils.createExecContext(null,{sr:e.arcade.context.spatialReference}),modules:e.arcade.modules}:null}}function Vh(e){const t=e==null?void 0:e.expression;if(typeof t=="string"){const r=Sa(t);if(r!=null)return{cachedResult:r}}return null}async function Uh(e,t,r,i){const s=e==null?void 0:e.expression;if(typeof s!="string")return null;const a=Sa(s);if(a!=null)return{cachedResult:a};const o=await so();ao(r);const l=o.arcadeUtils,c=l.createSyntaxTree(s);return l.dependsOnView(c)?(i!=null&&i.error("Expressions containing '$view' are not supported on ElevationInfo"),{cachedResult:0}):{arcade:{func:l.createFunction(c),context:l.createExecContext(null,{sr:t}),modules:o}}}function Gl(e,t,r){return e.arcadeUtils.createFeature(t.attributes,t.geometry,r)}function Wl(e,t){if(e!=null&&!Ca(e)){if(!t||!e.arcade)return void Ul().errorOncePerTick("Arcade support required but not provided");const r=t;r._geometry&&(r._geometry=Sn(r._geometry)),e.arcade.modules.arcadeUtils.updateExecContext(e.arcade.context,t)}}function Bl(e){if(e!=null){if(Ca(e))return e.cachedResult;const t=e.arcade;let r=t==null?void 0:t.modules.arcadeUtils.executeFunction(t.func,t.context);return typeof r!="number"&&(e.cachedResult=0,r=0),r}return 0}function Hh(e,t=!1){let r=e==null?void 0:e.featureExpressionInfo;const i=r==null?void 0:r.expression;return t||i==="0"||(r=null),r??null}const Gh={cachedResult:0};function Ca(e){return e.cachedResult!=null}function Sa(e){return e==="0"?0:null}let Wh=class Ta{constructor(){this._meterUnitOffset=0,this._renderUnitOffset=0,this._unit="meters",this._metersPerElevationInfoUnit=1,this._featureExpressionInfoContext=null,this.centerPointInElevationSR=null,this.mode=null}get featureExpressionInfoContext(){return this._featureExpressionInfoContext}get meterUnitOffset(){return this._meterUnitOffset}get unit(){return this._unit}set unit(t){this._unit=t,this._metersPerElevationInfoUnit=oo(t)}get requiresSampledElevationInfo(){return this.mode!=="absolute-height"}reset(){this.mode=null,this._meterUnitOffset=0,this._renderUnitOffset=0,this._featureExpressionInfoContext=null,this.unit="meters"}set offsetMeters(t){this._meterUnitOffset=t,this._renderUnitOffset=0}set offsetElevationInfoUnits(t){this._meterUnitOffset=t*this._metersPerElevationInfoUnit,this._renderUnitOffset=0}addOffsetRenderUnits(t){this._renderUnitOffset+=t}geometryZWithOffset(t,r){const i=this.calculateOffsetRenderUnits(r);return this.featureExpressionInfoContext!=null?i:t+i}calculateOffsetRenderUnits(t){let r=this._meterUnitOffset;const i=this.featureExpressionInfoContext;return i!=null&&(r+=Bl(i)*this._metersPerElevationInfoUnit),r/t.unitInMeters+this._renderUnitOffset}setFromElevationInfo(t){this.mode=t.mode,this.unit=no(t.unit)?t.unit:"meters",this.offsetElevationInfoUnits=t.offset??0}updateFeatureExpressionInfoContext(t,r,i){if(t==null)return void(this._featureExpressionInfoContext=null);const s=t==null?void 0:t.arcade;s&&r!=null&&i!=null?(this._featureExpressionInfoContext=Hl(t),Wl(this._featureExpressionInfoContext,Gl(s.modules,r,i))):this._featureExpressionInfoContext=t}static fromElevationInfo(t){const r=new Ta;return t!=null&&r.setFromElevationInfo(t),r}},kl=class extends ha{get geometries(){return this._geometries}get transformation(){return this._transformation??Ge}set transformation(t){this._transformation=it(this._transformation??W(),t),this._invalidateBoundingVolume(),this._emit("transformationChanged",this)}get shaderTransformation(){return this._shaderTransformation}set shaderTransformation(t){this._shaderTransformation=t?it(this._shaderTransformation??W(),t):null,this._invalidateBoundingVolume(),this._emit("shaderTransformationChanged",this)}get effectiveTransformation(){return this.shaderTransformation??this.transformation}constructor(t={}){super(),this.type=Nt.Object,this._shaderTransformation=null,this._parentLayer=null,this._visible=!0,this.castShadow=t.castShadow??!0,this.usesVerticalDistanceToGround=t.usesVerticalDistanceToGround??!1,this.graphicUid=t.graphicUid,this.layerUid=t.layerUid,t.isElevationSource&&(this.lastValidElevationBB=new Ra),this._geometries=t.geometries?Array.from(t.geometries):new Array}dispose(){this._geometries.length=0}get parentLayer(){return this._parentLayer}set parentLayer(t){pe(this._parentLayer==null||t==null,"Object3D can only be added to a single Layer"),this._parentLayer=t}addGeometry(t){t.visible=this._visible,this._geometries.push(t),this._emit("geometryAdded",{object:this,geometry:t}),this._invalidateBoundingVolume()}removeGeometry(t){const r=this._geometries.splice(t,1)[0];r&&(this._emit("geometryRemoved",{object:this,geometry:r}),this._invalidateBoundingVolume())}removeAllGeometries(){for(;this._geometries.length>0;)this.removeGeometry(0)}geometryVertexAttributeUpdated(t,r,i=!1){this._emit("attributesChanged",{object:this,geometry:t,attribute:r,sync:i}),_n(r)&&this._invalidateBoundingVolume()}get visible(){return this._visible}set visible(t){if(this._visible!==t){this._visible=t;for(const r of this._geometries)r.visible=this._visible;this._emit("visibilityChanged",this)}}maskOccludee(){const t=new ls(gs.MaskOccludee);for(const r of this._geometries)r.occludees=cs(r.occludees,t);return this._emit("occlusionChanged",this),t}removeOcclude(t){for(const r of this._geometries)r.occludees=ds(r.occludees,t);this._emit("occlusionChanged",this)}highlight(){const t=new ls(gs.Highlight);for(const r of this._geometries)r.highlights=cs(r.highlights,t);return this._emit("highlightChanged",this),t}removeHighlight(t){for(const r of this._geometries)r.highlights=ds(r.highlights,t);this._emit("highlightChanged",this)}getCombinedStaticTransformation(t,r){return Be(r,this.transformation,t.transformation)}getCombinedShaderTransformation(t,r=W()){return Be(r,this.effectiveTransformation,t.transformation)}get boundingVolumeWorldSpace(){return this._bvWorldSpace||(this._bvWorldSpace=this._bvWorldSpace||new Cs,this._validateBoundingVolume(this._bvWorldSpace,qt.WorldSpace)),this._bvWorldSpace}get boundingVolumeObjectSpace(){return this._bvObjectSpace||(this._bvObjectSpace=this._bvObjectSpace||new Cs,this._validateBoundingVolume(this._bvObjectSpace,qt.ObjectSpace)),this._bvObjectSpace}_validateBoundingVolume(t,r){const i=r===qt.ObjectSpace;for(const s of this._geometries){const a=s.boundingInfo;a&&ql(a,t,i?s.transformation:this.getCombinedShaderTransformation(s))}lo(Mr(t.bounds),t.min,t.max,.5);for(const s of this._geometries){const a=s.boundingInfo;if(a==null)continue;const o=i?s.transformation:this.getCombinedShaderTransformation(s),l=ga(o);ye(Ss,a.center,o);const c=jr(Ss,Mr(t.bounds)),n=a.radius*l;t.bounds[3]=Math.max(t.bounds[3],c+n)}}_invalidateBoundingVolume(){var r;const t=(r=this._bvWorldSpace)==null?void 0:r.bounds;this._bvObjectSpace=this._bvWorldSpace=void 0,this._parentLayer&&t&&this._parentLayer.notifyObjectBBChanged(this,t)}_emit(t,r){this._parentLayer&&this._parentLayer.events.emit(t,r)}get test(){const t=this;return{hasGeometry:r=>t._geometries.includes(r),getGeometryIndex:r=>t._geometries.indexOf(r)}}},Ra=class{constructor(){this.min=st(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this.max=st(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE)}isEmpty(){return this.max[0]<this.min[0]&&this.max[1]<this.min[1]&&this.max[2]<this.min[2]}},Cs=class extends Ra{constructor(){super(...arguments),this.bounds=da()}};function ql(e,t,r){const i=e.bbMin,s=e.bbMax;if(co(r)){const a=Q(Zl,r[12],r[13],r[14]);le(_e,i,a),le(Se,s,a);for(let o=0;o<3;++o)t.min[o]=Math.min(t.min[o],_e[o]),t.max[o]=Math.max(t.max[o],Se[o])}else if(ye(_e,i,r),St(i,s))for(let a=0;a<3;++a)t.min[a]=Math.min(t.min[a],_e[a]),t.max[a]=Math.max(t.max[a],_e[a]);else{ye(Se,s,r);for(let a=0;a<3;++a)t.min[a]=Math.min(t.min[a],_e[a],Se[a]),t.max[a]=Math.max(t.max[a],_e[a],Se[a]);for(let a=0;a<3;++a){X(_e,i),X(Se,s),_e[a]=s[a],Se[a]=i[a],ye(_e,_e,r),ye(Se,Se,r);for(let o=0;o<3;++o)t.min[o]=Math.min(t.min[o],_e[o],Se[o]),t.max[o]=Math.max(t.max[o],_e[o],Se[o])}}}const Zl=E(),_e=E(),Se=E(),Ss=E();var qt;(function(e){e[e.WorldSpace=0]="WorldSpace",e[e.ObjectSpace=1]="ObjectSpace"})(qt||(qt={}));var Zt,Pr,Ci;(function(e){e[e.RasterImage=0]="RasterImage",e[e.Features=1]="Features"})(Zt||(Zt={})),function(e){e[e.MapLayer=0]="MapLayer",e[e.ViewLayer=1]="ViewLayer",e[e.Outline=2]="Outline",e[e.SnappingHint=3]="SnappingHint"}(Pr||(Pr={})),function(e){e[e.WithRasterImage=0]="WithRasterImage",e[e.WithoutRasterImage=1]="WithoutRasterImage"}(Ci||(Ci={}));var be,Ts,Rs,Os;(function(e){e[e.INNER=0]="INNER",e[e.OUTER=1]="OUTER"})(be||(be={})),function(e){e[e.REGULAR=0]="REGULAR",e[e.HAS_NORTH_POLE=1]="HAS_NORTH_POLE",e[e.HAS_SOUTH_POLE=2]="HAS_SOUTH_POLE",e[e.HAS_BOTH_POLES=3]="HAS_BOTH_POLES"}(Ts||(Ts={})),function(e){e[e.OFF=0]="OFF",e[e.ON=1]="ON"}(Rs||(Rs={})),function(e){e[e.FADING=0]="FADING",e[e.IMMEDIATE=1]="IMMEDIATE",e[e.UNFADED=2]="UNFADED"}(Os||(Os={}));let Ql=class{constructor(t,r){this.vec3=t,this.id=r}};function Si(e,t,r,i){return new Ql(st(e,t,r),i)}let bs=class{constructor(){this._extent=wr(),this.resolution=0,this.renderLocalOrigin=Si(0,0,0,"O"),this.pixelRatio=1,this.mapUnitsPerPixel=1,this.canvasGeometries=new Jl}get extent(){return this._extent}setupGeometryViewsCyclical(t){this.setupGeometryViewsDirect();const r=.001*t.range;if(this._extent[0]-r<=t.min){const i=this.canvasGeometries.extents[this.canvasGeometries.numViews++];Qi(this._extent,t.range,0,i)}if(this._extent[2]+r>=t.max){const i=this.canvasGeometries.extents[this.canvasGeometries.numViews++];Qi(this._extent,-t.range,0,i)}}setupGeometryViewsDirect(){this.canvasGeometries.numViews=1,ho(this.canvasGeometries.extents[0],this._extent)}hasSomeSizedView(){for(let t=0;t<this.canvasGeometries.numViews;t++){const r=this.canvasGeometries.extents[t];if(r[0]!==r[2]&&r[1]!==r[3])return!0}return!1}},Jl=class{constructor(){this.extents=[wr(),wr(),wr()],this.numViews=0}};var Y;(function(e){e[e.Color=0]="Color",e[e.ColorNoRasterImage=1]="ColorNoRasterImage",e[e.Highlight=2]="Highlight",e[e.WaterNormal=3]="WaterNormal",e[e.Occluded=4]="Occluded",e[e.ObjectAndLayerIdColor=5]="ObjectAndLayerIdColor"})(Y||(Y={}));let Yl=class{constructor(t,r,i){this._fbos=t,this._format=r,this._name=i}get valid(){var t;return((t=this._handle)==null?void 0:t.getTexture())!=null}dispose(){this._handle=br(this._handle)}get texture(){var t;return(t=this._handle)==null?void 0:t.getTexture()}bind(t,r,i){var s,a,o;this._handle&&this._handle.fbo.width===r&&this._handle.fbo.height===i||((s=this._handle)==null||s.release(),this._handle=this._fbos.acquire(r,i,this._name,this._format)),t.unbindTexture((a=this._handle)==null?void 0:a.fbo.colorTexture),t.bindFramebuffer((o=this._handle)==null?void 0:o.fbo)}generateMipMap(){var t,r,i,s,a;(i=(r=(t=this._handle)==null?void 0:t.getTexture())==null?void 0:r.descriptor)!=null&&i.hasMipmap&&((a=(s=this._handle)==null?void 0:s.getTexture())==null||a.generateMipmap())}},_t=class{constructor(t,r,i,s,a=Dr.RGBA_MIPMAP){this.output=i,this.content=s,this.fbo=new Yl(t,a,r)}get valid(){return this.fbo.valid}},Xl=class{constructor(t){this.targets=[new _t(t,"overlay color",M.Color,Y.Color),new _t(t,"overlay IM color",M.Color,Y.ColorNoRasterImage),new _t(t,"overlay highlight",M.Highlight,Y.Highlight,Dr.RGBA4),new _t(t,"overlay water",M.Normal,Y.WaterNormal),new _t(t,"overlay occluded",M.Color,Y.Occluded)],Mt("enable-feature:objectAndLayerId-rendering")&&this.targets.push(new _t(t,"overlay oid",M.ObjectAndLayerIdColor,Y.ObjectAndLayerIdColor))}getTexture(t){var r;return(r=this.targets[t])==null?void 0:r.fbo.texture}dispose(){for(const t of this.targets)t.fbo.dispose()}computeValidity(){return this.targets.reduce((t,r,i)=>r.valid?t|=1<<i:t,0)}},zi=class extends Oo{constructor(){super(...arguments),this.slicePlaneLocalOrigin=E(),this.origin=this.slicePlaneLocalOrigin,this.modelTransformation=null}};var We;(function(e){e[e.Material=0]="Material",e[e.ShadowMap=1]="ShadowMap",e[e.Highlight=2]="Highlight"})(We||(We={}));let tu=class extends zi{constructor(){super(...arguments),this.identifier=We.Material,this.output=M.Color,this.transparent=!1}},iu=class extends zi{constructor(){super(...arguments),this.identifier=We.ShadowMap}},au=class extends zi{constructor(){super(...arguments),this.identifier=We.Highlight}};function nu(e){e.fragment.code.add(w`float normals2FoamIntensity(vec3 n, float waveStrength){
float normalizationFactor =  max(0.015, waveStrength);
return max((n.x + n.y)*0.3303545/normalizationFactor + 0.3303545, 0.0);
}`)}function Kl(e){e.fragment.code.add(w`vec3 foamIntensity2FoamColor(float foamIntensityExternal, float foamPixelIntensity, vec3 skyZenitColor, float dayMod){
return foamIntensityExternal * (0.075 * skyZenitColor * pow(foamPixelIntensity, 4.) +  50.* pow(foamPixelIntensity, 23.0)) * dayMod;
}`)}function ec(e,t){const r=e.fragment;r.include(oa),r.uniforms.add(new Di("nearFar",(i,s)=>s.camera.nearFar)),r.uniforms.add(new ke("depthMap",(i,s)=>{var a;return(a=s.linearDepth)==null?void 0:a.getTexture()})),r.uniforms.add(new Ft("proj",(i,s)=>s.camera.projectionMatrix)),r.uniforms.add(new Z("invResolutionHeight",(i,s)=>1/s.camera.height)),r.uniforms.add(new Ft("reprojectionMatrix",(i,s)=>s.ssr.reprojectionMatrix)),r.code.add(w`
  vec2 reprojectionCoordinate(vec3 projectionCoordinate)
  {
    vec4 zw = proj * vec4(0.0, 0.0, -projectionCoordinate.z, 1.0);
    vec4 reprojectedCoord = reprojectionMatrix * vec4(zw.w * (projectionCoordinate.xy * 2.0 - 1.0), zw.z, zw.w);
    reprojectedCoord.xy /= reprojectedCoord.w;
    return reprojectedCoord.xy * 0.5 + 0.5;
  }

  const int maxSteps = ${t.highStepCount?"150":"75"};

  vec4 applyProjectionMat(mat4 projectionMat, vec3 x)
  {
    vec4 projectedCoord =  projectionMat * vec4(x, 1.0);
    projectedCoord.xy /= projectedCoord.w;
    projectedCoord.xy = projectedCoord.xy*0.5 + 0.5;
    return projectedCoord;
  }

  vec3 screenSpaceIntersection(vec3 dir, vec3 startPosition, vec3 viewDir, vec3 normal)
  {
    vec3 viewPos = startPosition;
    vec3 viewPosEnd = startPosition;

    // Project the start position to the screen
    vec4 projectedCoordStart = applyProjectionMat(proj, viewPos);
    vec3  Q0 = viewPos / projectedCoordStart.w; // homogeneous camera space
    float k0 = 1.0/ projectedCoordStart.w;

    // advance the position in the direction of the reflection
    viewPos += dir;

    vec4 projectedCoordVanishingPoint = applyProjectionMat(proj, dir);

    // Project the advanced position to the screen
    vec4 projectedCoordEnd = applyProjectionMat(proj, viewPos);
    vec3  Q1 = viewPos / projectedCoordEnd.w; // homogeneous camera space
    float k1 = 1.0/ projectedCoordEnd.w;

    // calculate the reflection direction in the screen space
    vec2 projectedCoordDir = (projectedCoordEnd.xy - projectedCoordStart.xy);
    vec2 projectedCoordDistVanishingPoint = (projectedCoordVanishingPoint.xy - projectedCoordStart.xy);

    float yMod = min(abs(projectedCoordDistVanishingPoint.y), 1.0);

    float projectedCoordDirLength = length(projectedCoordDir);
    float maxSt = float(maxSteps);

    // normalize the projection direction depending on maximum steps
    // this determines how blocky the reflection looks
    vec2 dP = yMod * (projectedCoordDir)/(maxSt * projectedCoordDirLength);

    // Normalize the homogeneous camera space coordinates
    vec3  dQ = yMod * (Q1 - Q0)/(maxSt * projectedCoordDirLength);
    float dk = yMod * (k1 - k0)/(maxSt * projectedCoordDirLength);

    // initialize the variables for ray marching
    vec2 P = projectedCoordStart.xy;
    vec3 Q = Q0;
    float k = k0;
    float rayStartZ = -startPosition.z; // estimated ray start depth value
    float rayEndZ = -startPosition.z;   // estimated ray end depth value
    float prevEstimateZ = -startPosition.z;
    float rayDiffZ = 0.0;
    float dDepth;
    float depth;
    float rayDiffZOld = 0.0;

    // early outs
    if (dot(normal, dir) < 0.0 || dot(-viewDir, normal) < 0.0)
      return vec3(P, 0.0);

    for(int i = 0; i < maxSteps-1; i++)
    {
      depth = -linearDepthFromTexture(depthMap, P, nearFar); // get linear depth from the depth buffer

      // estimate depth of the marching ray
      rayStartZ = prevEstimateZ;
      dDepth = -rayStartZ - depth;
      rayEndZ = (dQ.z * 0.5 + Q.z)/ ((dk * 0.5 + k));
      rayDiffZ = rayEndZ- rayStartZ;
      prevEstimateZ = rayEndZ;

      if(-rayEndZ > nearFar[1] || -rayEndZ < nearFar[0] || P.y < 0.0  || P.y > 1.0 )
      {
        return vec3(P, 0.);
      }

      // If we detect a hit - return the intersection point, two conditions:
      //  - dDepth > 0.0 - sampled point depth is in front of estimated depth
      //  - if difference between dDepth and rayDiffZOld is not too large
      //  - if difference between dDepth and 0.025/abs(k) is not too large
      //  - if the sampled depth is not behind far plane or in front of near plane

      if((dDepth) < 0.025/abs(k) + abs(rayDiffZ) && dDepth > 0.0 && depth > nearFar[0] && depth < nearFar[1] && abs(P.y - projectedCoordStart.y) > invResolutionHeight)
      {
        return vec3(P, depth);
      }

      // continue with ray marching
      P = clamp(P + dP, vec2(0.0), vec2(0.999));
      Q.z += dQ.z;
      k += dk;
      rayDiffZOld = rayDiffZ;
    }
    return vec3(P, 0.0);
  }
  `)}function tc(e,t){e.include(bo,t),e.include(rl),e.include(Kl),t.hasCloudsReflections&&e.include(ul,t),t.hasScreenSpaceReflections&&e.include(ec,t);const r=e.fragment;r.constants.add("fresnelSky","vec3",[.02,1,15]).add("fresnelMaterial","vec2",[.02,.1]).add("roughness","float",.015).add("foamIntensityExternal","float",1.7).add("ssrIntensity","float",.65).add("ssrHeightFadeStart","float",Ao).add("ssrHeightFadeEnd","float",Do).add("waterDiffusion","float",.92).add("waterSeaColorMod","float",.8).add("correctionViewingPowerFactor","float",.4).add("skyZenitColor","vec3",[.52,.68,.9]).add("skyColor","vec3",[.67,.79,.9]).add("cloudFresnelModifier","vec2",[1.2,.01]),r.code.add(w`PBRShadingWater shadingInfo;
vec3 getSkyGradientColor(in float cosTheta, in vec3 horizon, in vec3 zenit) {
float exponent = pow((1.0 - cosTheta), fresnelSky[2]);
return mix(zenit, horizon, exponent);
}`),r.uniforms.add(new Z("lightingSpecularStrength",(i,s)=>s.lighting.mainLight.specularStrength),new Z("lightingEnvironmentStrength",(i,s)=>s.lighting.mainLight.environmentStrength)),r.code.add(w`vec3 getSeaColor(in vec3 n, in vec3 v, in vec3 l, vec3 color, in vec3 lightIntensity, in vec3 localUp, in float shadow, float foamIntensity, vec3 viewPosition, vec3 position) {
float reflectionHit = 0.0;
float reflectionHitDiffused = 0.0;
vec3 seaWaterColor = linearizeGamma(color);
vec3 h = normalize(l + v);
shadingInfo.NdotL = clamp(dot(n, l), 0.0, 1.0);
shadingInfo.NdotV = clamp(dot(n, v), 0.001, 1.0);
shadingInfo.VdotN = clamp(dot(v, n), 0.001, 1.0);
shadingInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);
shadingInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);
shadingInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);
float upDotV = max(dot(localUp,v), 0.0);
vec3 skyHorizon = linearizeGamma(skyColor);
vec3 skyZenit = linearizeGamma(skyZenitColor);
vec3 skyColor = getSkyGradientColor(upDotV, skyHorizon, skyZenit );
float upDotL = max(dot(localUp,l),0.0);
float daytimeMod = 0.1 + upDotL * 0.9;
skyColor *= daytimeMod;
float shadowModifier = clamp(shadow, 0.8, 1.0);
vec3 fresnelModifier = fresnelReflection(shadingInfo.VdotN, vec3(fresnelSky[0]), fresnelSky[1]);
vec3 reflSky = lightingEnvironmentStrength * fresnelModifier * skyColor * shadowModifier;
vec3 reflSea = seaWaterColor * mix(skyColor, upDotL * lightIntensity * LIGHT_NORMALIZATION, 2.0 / 3.0) * shadowModifier;
vec3 specular = vec3(0.0);
if(upDotV > 0.0 && upDotL > 0.0) {
vec3 specularSun = brdfSpecularWater(shadingInfo, roughness, vec3(fresnelMaterial[0]), fresnelMaterial[1]);
vec3 incidentLight = lightIntensity * LIGHT_NORMALIZATION * shadow;
specular = lightingSpecularStrength * shadingInfo.NdotL * incidentLight * specularSun;
}
vec3 foam = vec3(0.0);
if(upDotV > 0.0) {
foam = foamIntensity2FoamColor(foamIntensityExternal, foamIntensity, skyZenitColor, daytimeMod);
}
float correctionViewingFactor = pow(max(dot(v, localUp), 0.0), correctionViewingPowerFactor);
vec3 normalCorrectedClouds = mix(localUp, n, correctionViewingFactor);
vec3 reflectedWorld = normalize(reflect(-v, normalCorrectedClouds));`),t.hasCloudsReflections&&r.code.add(w`vec4 cloudsColor = renderClouds(reflectedWorld, position);
cloudsColor.a = 1.0 - cloudsColor.a;
cloudsColor = pow(cloudsColor, vec4(GAMMA));
cloudsColor *= clamp(fresnelModifier.y * cloudFresnelModifier[0] - cloudFresnelModifier[1], 0.0, 1.0) * clamp((1.0 - totalFadeInOut), 0.0, 1.0);`),t.hasScreenSpaceReflections?(r.uniforms.add(new Ft("view",(i,s)=>s.camera.viewMatrix),new ke("lastFrameColorTexture",(i,s)=>{var a;return(a=s.ssr.lastFrameColor)==null?void 0:a.getTexture()}),new Z("fadeFactorSSR",(i,s)=>s.ssr.fadeFactor)),r.code.add(w`vec3 viewDir = normalize(viewPosition);
vec4 viewNormalVectorCoordinate = view *vec4(n, 0.0);
vec3 viewNormal = normalize(viewNormalVectorCoordinate.xyz);
vec4 viewUp = view * vec4(localUp, 0.0);
vec3 viewNormalCorrectedSSR = mix(viewUp.xyz, viewNormal, correctionViewingFactor);
vec3 reflected = normalize(reflect(viewDir, viewNormalCorrectedSSR));
vec3 hitCoordinate = screenSpaceIntersection(reflected, viewPosition, viewDir, viewUp.xyz);
vec3 reflectedColor = vec3(0.0);
if (hitCoordinate.z > 0.0)
{
vec2 reprojectedCoordinate = reprojectionCoordinate(hitCoordinate);
vec2 dCoords = smoothstep(0.3, 0.6, abs(vec2(0.5, 0.5) - hitCoordinate.xy));
float heightMod = smoothstep(ssrHeightFadeEnd, ssrHeightFadeStart, -viewPosition.z);
reflectionHit = clamp(1.0 - (1.3 * dCoords.y), 0.0, 1.0) * heightMod * fadeFactorSSR;
reflectionHitDiffused = waterDiffusion * reflectionHit;
reflectedColor = linearizeGamma(texture(lastFrameColorTexture, reprojectedCoordinate).xyz) *
reflectionHitDiffused * fresnelModifier.y * ssrIntensity;
}
float seaColorMod =  mix(waterSeaColorMod, waterSeaColorMod * 0.5, reflectionHitDiffused);
vec3 waterRenderedColor = tonemapACES((1.0 - reflectionHitDiffused) * reflSky + reflectedColor +
reflSea * seaColorMod + specular + foam);`)):r.code.add(w`vec3 waterRenderedColor = tonemapACES(reflSky + reflSea * waterSeaColorMod + specular + foam);`),t.hasCloudsReflections?t.hasScreenSpaceReflections?r.code.add(w`return waterRenderedColor * (1.0 - (1.0 - reflectionHit) * cloudsColor.a) + (1.0 - reflectionHit) * cloudsColor.xyz;
}`):r.code.add(w`return waterRenderedColor * (1.0 - cloudsColor.a) + cloudsColor.xyz;
}`):r.code.add(w`return waterRenderedColor;
}`)}let As=class extends Ai{constructor(t,r){super(t,"vec4",fa.Draw,(i,s,a)=>i.setUniform4fv(t,r(s,a)))}};var At;function cu(e,t){const{vertex:r,fragment:i}=e;r.uniforms.add(new As("overlayTexOffset",(s,a)=>ic(s,a)),new As("overlayTexScale",(s,a)=>sc(s,a))),i.constants.add("overlayOpacity","float",1),i.uniforms.add(new ke("ovColorTex",(s,a)=>rc(s,a))),Oa(e,t)}function du(e,t){const{vertex:r,fragment:i}=e;r.uniforms.add(new Ds("overlayTexOffset"),new Ds("overlayTexScale")),i.uniforms.add(new Z("overlayOpacity",s=>s.overlayOpacity),new ke("ovColorTex",(s,a)=>{var o;return(o=a.overlay)==null?void 0:o.getTexture(s.overlayContent)})),Oa(e,t)}(function(e){e[e.Disabled=0]="Disabled",e[e.Enabled=1]="Enabled",e[e.EnabledWithWater=2]="EnabledWithWater",e[e.COUNT=3]="COUNT"})(At||(At={}));let Ds=class extends Ai{constructor(t){super(t,"vec4")}};function Oa(e,t){t.pbrMode!==ct.Water&&t.pbrMode!==ct.WaterOnIntegratedMesh&&t.pbrMode!==ct.TerrainWithWater||e.include(tc,t);const{vertex:r,fragment:i}=e;e.varyings.add("vtcOverlay","vec4"),r.code.add(w`void setOverlayVTC(in vec2 uv) {
vtcOverlay = vec4(uv, uv) * overlayTexScale + overlayTexOffset;
}`),i.code.add(w`bool isValid(vec2 uv, vec2 dxdy) {
return (uv.x >= 0.0 + dxdy.x) && (uv.x <= 1.0 - dxdy.x) && (uv.y >= 0.0 + dxdy.y) && (uv.y <= 1.0 - dxdy.y);
}
vec4 getOverlayColor(sampler2D ov0Tex, vec4 texCoords) {
vec4 color0 = texture(ov0Tex, vec2(texCoords.x * 0.5, texCoords.y));
vec4 color1 = texture(ov0Tex, vec2(texCoords.z * 0.5 + 0.5, texCoords.w));
bool isValid0 = isValid(texCoords.xy, fwidth(texCoords.xy));
bool isValid1 = isValid(texCoords.zw, vec2(0.0, 0.0));
return mix(color1 * float(isValid1), color0, float(isValid0));
}`),i.code.add(w`vec4 getCombinedOverlayColor() {
return overlayOpacity * getOverlayColor(ovColorTex, vtcOverlay);
}`),i.code.add(w`vec4 getOverlayColorTexel(vec4 texCoords) {
vec2 texDim =  vec2(textureSize(ovColorTex, 0));
vec4 color0 = texelFetch(ovColorTex, ivec2(vec2(texCoords.x * 0.5, texCoords.y) * texDim), 0);
vec4 color1 = texelFetch(ovColorTex, ivec2(vec2(texCoords.z * 0.5 + 0.5, texCoords.w) * texDim), 0);
bool isValid0 = isValid(texCoords.xy, fwidth(texCoords.xy));
bool isValid1 = isValid(texCoords.zw, vec2(0.0, 0.0));
return mix(color1 * float(isValid1), color0, float(isValid0));
}`),t.pbrMode!==ct.Water&&t.pbrMode!==ct.WaterOnIntegratedMesh&&t.pbrMode!==ct.TerrainWithWater||(sa(i),aa(i),i.code.add(w`vec4 getOverlayWaterColor(vec4 maskInput, vec4 colorInput, vec3 vposEyeDir,
float shadow, vec3 localUp, mat3 tbn, vec3 position, vec3 positionWorld) {
vec3 n = normalize(tbn *  (2.0 * maskInput.rgb - vec3(1.0)));
vec3 v = vposEyeDir;
vec3 final = getSeaColor(n, v, mainLightDirection, colorInput.rgb, mainLightIntensity, localUp, 1.0 - shadow, maskInput.w, position, positionWorld);
return vec4(final, colorInput.w);
}`))}function rc(e,t){var r,i,s;return e.identifier===We.Material&&e.output===M.Color?(r=t.overlay)==null?void 0:r.getTexture(Y.ColorNoRasterImage):e.identifier===We.Material&&e.output===M.ObjectAndLayerIdColor?(i=t.overlay)==null?void 0:i.getTexture(Y.ObjectAndLayerIdColor):e.identifier===We.Highlight?(s=t.overlay)==null?void 0:s.getTexture(Y.Highlight):null}function ic(e,t){var s,a,o,l;const r=(a=(s=t.overlay)==null?void 0:s.overlays[be.INNER])==null?void 0:a.extent;Ar(r)&&(Ie[0]=e.toMapSpace[0]/Tt(r)-r[0]/Tt(r),Ie[1]=e.toMapSpace[1]/Rt(r)-r[1]/Rt(r));const i=(l=(o=t.overlay)==null?void 0:o.overlays[be.OUTER])==null?void 0:l.extent;return Ar(i)&&(Ie[2]=e.toMapSpace[0]/Tt(i)-i[0]/Tt(i),Ie[3]=e.toMapSpace[1]/Rt(i)-i[1]/Rt(i)),Ie}function sc(e,t){var s,a,o,l;const r=(a=(s=t.overlay)==null?void 0:s.overlays[be.INNER])==null?void 0:a.extent;Ar(r)&&(Ie[0]=e.toMapSpace[2]/Tt(r),Ie[1]=e.toMapSpace[3]/Rt(r));const i=(l=(o=t.overlay)==null?void 0:o.overlays[be.OUTER])==null?void 0:l.extent;return Ar(i)&&(Ie[2]=e.toMapSpace[2]/Tt(i),Ie[3]=e.toMapSpace[3]/Rt(i)),Ie}const Ie=Ve();let ba=class extends pa{constructor(){super(...arguments),this.color=st(1,1,1)}};function ac(){const e=new Mi;return e.include(na),e.fragment.uniforms.add(new ke("tex",t=>t.texture),new et("uColor",t=>t.color)),e.fragment.code.add(w`void main() {
vec4 texColor = texture(tex, uv);
fragColor = texColor * vec4(uColor, 1.0);
}`),e}const oc=Object.freeze(Object.defineProperty({__proto__:null,TextureOnlyPassParameters:ba,build:ac},Symbol.toStringTag,{value:"Module"}));let nc=class{constructor(t){this._context=t,this._perConstructorInstances=new Fi,this._frameCounter=0,this._keepAliveFrameCount=Ms}get viewingMode(){return this._context.viewingMode}get constructionContext(){return this._context}destroy(){this._perConstructorInstances.forEach(t=>t.forEach(r=>r.technique.destroy())),this._perConstructorInstances.clear()}acquire(t,r=cc){const i=r.key;let s=this._perConstructorInstances.get(t,i);if(s==null){const a=new t(this._context,r,()=>this.release(a));s=new lc(a),this._perConstructorInstances.set(t,i,s)}return++s.refCount,s.technique}releaseAndAcquire(t,r,i){if(i!=null){if(r.key===i.key)return i;this.release(i)}return this.acquire(t,r)}release(t){if(t==null||this._perConstructorInstances.empty)return;const r=this._perConstructorInstances.get(t.constructor,t.key);r!=null&&(--r.refCount,r.refCount===0&&(r.refZeroFrame=this._frameCounter))}frameUpdate(){this._frameCounter++,this._keepAliveFrameCount!==Ms&&this._perConstructorInstances.forEach((t,r)=>{t.forEach((i,s)=>{i.refCount===0&&i.refZeroFrame+this._keepAliveFrameCount<this._frameCounter&&(i.technique.destroy(),this._perConstructorInstances.delete(r,s))})})}async reloadAll(){const t=new Array;this._perConstructorInstances.forEach((r,i)=>{const s=async(a,o)=>{const l=o.shader;l&&(await l.reload(),a.forEach(c=>c.technique.reload(this._context)))};t.push(s(r,i))}),await Promise.all(t)}},lc=class{constructor(t){this.technique=t,this.refCount=0,this.refZeroFrame=0}};const Ms=-1,cc=new ma;let dc=class{constructor(t,r,i,s){this._textureRepository=t,this._techniqueRepository=r,this.materialChanged=i,this.requestRender=s,this._id2glMaterialRef=new Fi}dispose(){this._textureRepository.destroy()}acquire(t,r,i){this._ownMaterial(t);const s=t.produces.get(r);if(!s||!s(i))return null;let a=this._id2glMaterialRef.get(i,t.id);if(a==null){const o=t.createGLMaterial({material:t,techniqueRep:this._techniqueRepository,textureRepository:this._textureRepository,output:i});a=new hc(o),this._id2glMaterialRef.set(i,t.id,a)}return a.ref(),a.glMaterial}release(t,r){const i=this._id2glMaterialRef.get(r,t.id);i!=null&&(i.unref(),i.referenced||(Yt(i.glMaterial),this._id2glMaterialRef.delete(r,t.id)))}_ownMaterial(t){t.repository&&t.repository!==this&&zr.getLogger("esri.views.3d.webgl-engine.lib.GLMaterialRepository").error("Material is already owned by a different material repository"),t.repository=this}},hc=class{constructor(t){this.glMaterial=t,this._refCnt=0}ref(){++this._refCnt}unref(){--this._refCnt,pe(this._refCnt>=0)}get referenced(){return this._refCnt>0}};const uc=["layerObjectAdded","layerObjectRemoved","layerObjectsAdded","layerObjectsRemoved","transformationChanged","shaderTransformationChanged","visibilityChanged","occlusionChanged","highlightChanged","geometryAdded","geometryRemoved","attributesChanged"];var Kt;(function(e){e[e.ASYNC=0]="ASYNC",e[e.SYNC=1]="SYNC"})(Kt||(Kt={}));let pc=class extends ha{get objects(){return this._objects}constructor(t,r,i=""){super(),this.stage=t,this.apiLayerUid=i,this.type=Nt.Layer,this.events=new ra,this.visible=!0,this.pickable=!0,this.sliceable=!1,this._objects=new Ae,this._objectsAdded=new Ae,this._handles=new uo,this.apiLayerUid=i,this.visible=(r==null?void 0:r.visible)??!0,this.pickable=(r==null?void 0:r.pickable)??!0,this.updatePolicy=(r==null?void 0:r.updatePolicy)??Kt.ASYNC,this._disableOctree=(r==null?void 0:r.disableOctree)??!1,t.add(this);for(const s of uc)this._handles.add(this.events.on(s,a=>t.handleEvent(s,a)))}destroy(){this._handles.size&&(this._handles.destroy(),this.stage.remove(this),this.invalidateSpatialQueryAccelerator())}add(t){this._objects.push(t),t.parentLayer=this,this.events.emit("layerObjectAdded",{layer:this,object:t}),this._octree!=null&&this._objectsAdded.push(t)}remove(t){this._objects.removeUnordered(t)&&(t.parentLayer=null,this.events.emit("layerObjectRemoved",{layer:this,object:t}),this._octree!=null&&(this._objectsAdded.removeUnordered(t)||this._octree.remove([t])))}addMany(t){this._objects.pushArray(t);for(const r of t)r.parentLayer=this;this.events.emit("layerObjectsAdded",{layer:this,objects:t}),this._octree!=null&&this._objectsAdded.pushArray(t)}removeMany(t){const r=new Array;if(this._objects.removeUnorderedMany(t,t.length,r),r.length!==0){for(const i of r)i.parentLayer=null;if(this.events.emit("layerObjectsRemoved",{layer:this,objects:r}),this._octree!=null){for(let i=0;i<r.length;)this._objectsAdded.removeUnordered(r[i])?(r[i]=r[r.length-1],r.length-=1):++i;this._octree.remove(r)}}}sync(){this.updatePolicy!==Kt.SYNC&&this.stage.syncLayer(this.id)}notifyObjectBBChanged(t,r){this._octree==null||this._objectsAdded.includes(t)||this._octree.update(t,r)}getSpatialQueryAccelerator(){return this._octree==null&&this._objects.length>50&&!this._disableOctree?(this._octree=new Ln(t=>t.boundingVolumeWorldSpace.bounds),this._octree.add(this._objects.data,this._objects.length)):this._octree!=null&&this._objectsAdded.length>0&&(this._octree.add(this._objectsAdded.data,this._objectsAdded.length),this._objectsAdded.clear()),this._octree}invalidateSpatialQueryAccelerator(){this._octree=ia(this._octree),this._objectsAdded.clear()}};function vu(e){return e!=null&&e.type===Nt.Layer}var at,er;(function(e){e[e.Draped=0]="Draped",e[e.Screen=1]="Screen",e[e.World=2]="World",e[e.COUNT=3]="COUNT"})(at||(at={})),function(e){e[e.Center=0]="Center",e[e.Tip=1]="Tip",e[e.COUNT=2]="COUNT"}(er||(er={}));let ee=class extends la{constructor(){super(...arguments),this.output=M.Color,this.transparencyPassType=Ue.NONE,this.occluder=!1,this.hasSlicePlane=!1,this.writeDepth=!1,this.space=at.Screen,this.hideOnShortSegments=!1,this.hasCap=!1,this.anchor=er.Center,this.hasTip=!1,this.vvSize=!1,this.vvColor=!1,this.vvOpacity=!1,this.hasOccludees=!1,this.multipassEnabled=!1,this.cullAboveGround=!1}get draped(){return this.space===at.Draped}};m([P({count:M.COUNT})],ee.prototype,"output",void 0),m([P({count:Ue.COUNT})],ee.prototype,"transparencyPassType",void 0),m([P()],ee.prototype,"occluder",void 0),m([P()],ee.prototype,"hasSlicePlane",void 0),m([P()],ee.prototype,"writeDepth",void 0),m([P({count:at.COUNT})],ee.prototype,"space",void 0),m([P()],ee.prototype,"hideOnShortSegments",void 0),m([P()],ee.prototype,"hasCap",void 0),m([P({count:er.COUNT})],ee.prototype,"anchor",void 0),m([P()],ee.prototype,"hasTip",void 0),m([P()],ee.prototype,"vvSize",void 0),m([P()],ee.prototype,"vvColor",void 0),m([P()],ee.prototype,"vvOpacity",void 0),m([P()],ee.prototype,"hasOccludees",void 0),m([P()],ee.prototype,"multipassEnabled",void 0),m([P()],ee.prototype,"cullAboveGround",void 0),m([P({constValue:!1})],ee.prototype,"occlusionPass",void 0),m([P({constValue:!0})],ee.prototype,"hasVvInstancing",void 0),m([P({constValue:!0})],ee.prototype,"hasSliceTranslatedView",void 0);const Es=8;function fc(e,t){const r=e.vertex;r.uniforms.add(new Z("intrinsicWidth",i=>i.width)),t.vvSize?(e.attributes.add(y.SIZEFEATUREATTRIBUTE,"float"),r.uniforms.add(new et("vvSizeMinSize",i=>i.vvSize.minSize),new et("vvSizeMaxSize",i=>i.vvSize.maxSize),new et("vvSizeOffset",i=>i.vvSize.offset),new et("vvSizeFactor",i=>i.vvSize.factor)),r.code.add(w`float getSize() {
return intrinsicWidth * clamp(vvSizeOffset + sizeFeatureAttribute * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).x;
}`)):(e.attributes.add(y.SIZE,"float"),r.code.add(w`float getSize(){
return intrinsicWidth * size;
}`)),t.vvOpacity?(e.attributes.add(y.OPACITYFEATUREATTRIBUTE,"float"),r.constants.add("vvOpacityNumber","int",8),r.uniforms.add(new rs("vvOpacityValues",i=>i.vvOpacity.values,Es),new rs("vvOpacityOpacities",i=>i.vvOpacity.opacityValues,Es)),r.code.add(w`float interpolateOpacity( float value ){
if (value <= vvOpacityValues[0]) {
return vvOpacityOpacities[0];
}
for (int i = 1; i < vvOpacityNumber; ++i) {
if (vvOpacityValues[i] >= value) {
float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);
return mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f);
}
}
return vvOpacityOpacities[vvOpacityNumber - 1];
}
vec4 applyOpacity( vec4 color ){
return vec4(color.xyz, interpolateOpacity(opacityFeatureAttribute));
}`)):r.code.add(w`vec4 applyOpacity( vec4 color ){
return color;
}`),t.vvColor?(e.include(Mo,t),e.attributes.add(y.COLORFEATUREATTRIBUTE,"float"),r.code.add(w`vec4 getColor(){
return applyOpacity(interpolateVVColor(colorFeatureAttribute));
}`)):(e.attributes.add(y.COLOR,"vec4"),r.code.add(w`vec4 getColor(){
return applyOpacity(color);
}`))}let mc=class{constructor(t,r,i){this._createTexture=t,this._parametersKey=r,this._repository=new Map,this._orphanCache=i.newCache(`procedural-texture-repository:${Oi()}`,s=>s.dispose())}destroy(){for(const[t,{texture:r}]of this._repository)r.dispose();this._repository.clear(),this._orphanCache.destroy()}swap(t,r=null){const i=this._acquire(t);return this.release(r),i}release(t){if(t==null)return;const r=this._parametersKey(t),i=this._repository.get(r);if(i&&(i.refCount--,i.refCount===0)){this._repository.delete(r);const{texture:s}=i,a=s.usedMemory;this._orphanCache.put(r,s,a)}}_acquire(t){if(t==null)return null;const r=this._parametersKey(t),i=this._repository.get(r);if(i)return i.refCount++,i.texture;const s=this._orphanCache.pop(r)??this._createTexture(t),a=new gc(s);return this._repository.set(r,a),s}},gc=class{constructor(t){this.texture=t,this.refCount=1}};function Cu(e,t){return new mc(r=>{const{encodedData:i,textureSize:s}=_c(r),a=new ji;return a.internalFormat=ya.RGBA,a.width=s,a.height=1,a.wrapMode=Er.REPEAT,new Xt(e,a,i)},r=>`${r.pattern.join(",")}-r${r.pixelRatio}`,t)}function _c(e){const t=Vi(e),r=1/e.pixelRatio,i=Aa(e),s=Da(e),a=(Math.floor(.5*(s-1))+.5)*r,o=[];let l=1;for(const p of t){for(let u=0;u<p;u++){const f=l*(Math.min(u,p-1-u)+.5)*r/a*.5+.5;o.push(f)}l=-l}const c=Math.round(t[0]/2),n=[...o.slice(c),...o.slice(0,c)],d=new Uint8Array(4*i);let h=0;for(const p of n)va(p,d,h),h+=4;return{encodedData:d,textureSize:i}}function Vi(e){return e.pattern.map(t=>Math.round(t*e.pixelRatio))}function Aa(e){if(e==null)return 1;const t=Vi(e);return Math.floor(t.reduce((r,i)=>r+i))}function Da(e){return Vi(e).reduce((t,r)=>Math.max(t,r))}function vc(e){return e==null?po:e.length===4?e:gi(yc,e[0],e[1],e[2],1)}const yc=Ve();function wc(e,t){e.constants.add("stippleAlphaColorDiscard","float",.001),e.constants.add("stippleAlphaHighlightDiscard","float",.5),t.stippleEnabled?xc(e,t):Cc(e)}function xc(e,t){const r=!(t.draped&&t.stipplePreferContinuous),{vertex:i,fragment:s}=e;s.include(Eo),t.draped||($o(i,t),i.uniforms.add(new Z("worldToScreenPerDistanceRatio",(a,o)=>1/o.camera.perScreenPixelRatio)),i.code.add(w`float computeWorldToScreenRatio(vec3 segmentCenter) {
float segmentDistanceToCamera = length(segmentCenter - cameraPosition);
return worldToScreenPerDistanceRatio / segmentDistanceToCamera;
}`)),e.varyings.add("vStippleDistance","float"),e.varyings.add("vStippleDistanceLimits","vec2"),e.varyings.add("vStipplePatternStretch","float"),i.code.add(w`
    float discretizeWorldToScreenRatio(float worldToScreenRatio) {
      float step = ${Tc};

      float discreteWorldToScreenRatio = log(worldToScreenRatio);
      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;
      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);
      return discreteWorldToScreenRatio;
    }
  `),i.code.add(w`vec2 computeStippleDistanceLimits(float startPseudoScreen, float segmentLengthPseudoScreen, float segmentLengthScreen, float patternLength) {`),i.code.add(w`
    if (segmentLengthPseudoScreen >= ${r?"patternLength":"1e4"}) {
  `),Ei(i),i.code.add(w`float repetitions = segmentLengthScreen / (patternLength * pixelRatio);
float flooredRepetitions = max(1.0, floor(repetitions + 0.5));
float segmentLengthScreenRounded = flooredRepetitions * patternLength;
float stretch = repetitions / flooredRepetitions;
vStipplePatternStretch = max(0.75, stretch);
return vec2(0.0, segmentLengthScreenRounded);
}
return vec2(startPseudoScreen, startPseudoScreen + segmentLengthPseudoScreen);
}`),s.uniforms.add(new ke("stipplePatternTexture",a=>a.stippleTexture),new Z("stipplePatternSDFNormalizer",a=>Sc(a.stipplePattern)),new Z("stipplePatternPixelSizeInv",a=>1/Ma(a))),s.code.add(w`float getStippleSDF(out bool isClamped) {
float stippleDistanceClamped = clamp(vStippleDistance, vStippleDistanceLimits.x, vStippleDistanceLimits.y);
vec2 aaCorrectedLimits = vStippleDistanceLimits + vec2(1.0, -1.0) / gl_FragCoord.w;
isClamped = vStippleDistance < aaCorrectedLimits.x || vStippleDistance > aaCorrectedLimits.y;
float u = stippleDistanceClamped * gl_FragCoord.w * stipplePatternPixelSizeInv * vLineSizeInv;
u = fract(u);
float encodedSDF = rgba2float(texture(stipplePatternTexture, vec2(u, 0.5)));
float sdf = (encodedSDF * 2.0 - 1.0) * stipplePatternSDFNormalizer;
return (sdf - 0.5) * vStipplePatternStretch + 0.5;
}
float getStippleSDF() {
bool ignored;
return getStippleSDF(ignored);
}
float getStippleAlpha() {
bool isClamped;
float stippleSDF = getStippleSDF(isClamped);
float antiAliasedResult = clamp(stippleSDF * vLineWidth + 0.5, 0.0, 1.0);
return isClamped ? floor(antiAliasedResult + 0.5) : antiAliasedResult;
}`),t.stippleOffColorEnabled?(s.uniforms.add(new xr("stippleOffColor",a=>vc(a.stippleOffColor))),s.code.add(w`#define discardByStippleAlpha(stippleAlpha, threshold) {}
#define blendStipple(color, stippleAlpha) mix(color, stippleOffColor, stippleAlpha)`)):s.code.add(w`#define discardByStippleAlpha(stippleAlpha, threshold) if (stippleAlpha < threshold) { discard; }
#define blendStipple(color, stippleAlpha) vec4(color.rgb, color.a * stippleAlpha)`)}function Cc(e){e.fragment.code.add(w`float getStippleAlpha() { return 1.0; }
#define discardByStippleAlpha(_stippleAlpha_, _threshold_) {}
#define blendStipple(color, _stippleAlpha_) color`)}function Sc(e){return e?(Math.floor(.5*(Da(e)-1))+.5)/e.pixelRatio:1}function Ma(e){const t=e.stipplePattern;return t?Aa(e.stipplePattern)/t.pixelRatio:1}const Tc=w.float(.4),Ea=128,$a=.5;function Su(e){return e==="cross"||e==="x"}function Tu(e,t=Ea,r=t*$a,i=0){const s=Ia(e,t,r,i);return new Io(s,{mipmap:!1,wrap:{s:Er.CLAMP_TO_EDGE,t:Er.CLAMP_TO_EDGE},width:t,height:t,components:4,noUnpackFlip:!0,reloadable:!0})}function Ia(e,t=Ea,r=t*$a,i=0){switch(e){case"circle":default:return Rc(t,r);case"square":return Oc(t,r);case"cross":return Ac(t,r,i);case"x":return Dc(t,r,i);case"kite":return bc(t,r);case"triangle":return Mc(t,r);case"arrow":return Ec(t,r)}}function Rc(e,t){const r=e/2-.5;return ir(e,Fa(r,r,t/2))}function Oc(e,t){return Pa(e,t,!1)}function bc(e,t){return Pa(e,t,!0)}function Ac(e,t,r=0){return La(e,t,!1,r)}function Dc(e,t,r=0){return La(e,t,!0,r)}function Mc(e,t){return ir(e,Na(e/2,t,t/2))}function Ec(e,t){const r=t,i=t/2,s=e/2,a=.8*r,o=Fa(s,(e-t)/2-a,Math.sqrt(a*a+i*i)),l=Na(s,r,i);return ir(e,(c,n)=>Math.max(l(c,n),-o(c,n)))}function Pa(e,t,r){return r&&(t/=Math.SQRT2),ir(e,(i,s)=>{let a=i-.5*e+.25,o=.5*e-s-.75;if(r){const l=(a+o)/Math.SQRT2;o=(o-a)/Math.SQRT2,a=l}return Math.max(Math.abs(a),Math.abs(o))-.5*t})}function La(e,t,r,i=0){t-=i,r&&(t*=Math.SQRT2);const s=.5*t;return ir(e,(a,o)=>{let l,c=a-.5*e,n=.5*e-o-1;if(r){const d=(c+n)/Math.SQRT2;n=(n-c)/Math.SQRT2,c=d}return c=Math.abs(c),n=Math.abs(n),l=c>n?c>s?Math.sqrt((c-s)*(c-s)+n*n):n:n>s?Math.sqrt(c*c+(n-s)*(n-s)):c,l-=i/2,l})}function Fa(e,t,r){return(i,s)=>{const a=i-e,o=s-t;return Math.sqrt(a*a+o*o)-r}}function Na(e,t,r){const i=Math.sqrt(t*t+r*r);return(s,a)=>{const o=Math.abs(s-e)-r,l=a-e+t/2+.75,c=(t*o+r*l)/i,n=-l;return Math.max(c,n)}}function ir(e,t){const r=new Uint8Array(4*e*e);for(let i=0;i<e;i++)for(let s=0;s<e;s++){const a=s+e*i;let o=t(s,i);o=o/e+.5,va(o,r,4*a)}return r}const Qt=64,ja=Qt/2,za=ja/5,$c=Qt/za,Ru=.25;function Ou(e,t){const r=Ia(e,Qt,ja,za),i=new ji;return i.internalFormat=ya.RGBA,i.width=Qt,i.height=Qt,i.wrapMode=Er.CLAMP_TO_EDGE,new Xt(t,i,r)}function Ic(e,t){const{vertex:r,constants:i}=e;i.add("markerSizePerLineWidth","float",$c),Ei(r),r.uniforms.get("markerScale")==null&&r.constants.add("markerScale","float",1),r.code.add(w`float getLineWidth() {
return max(getSize(), 1.0) * pixelRatio;
}
float getScreenMarkerSize() {
return markerSizePerLineWidth * markerScale * getLineWidth();
}`),t.space===at.World&&(r.constants.add("maxSegmentLengthFraction","float",.45),r.uniforms.add(new Z("perRenderPixelRatio",(s,a)=>a.camera.perRenderPixelRatio)),r.code.add(w`bool areWorldMarkersHidden(vec4 pos, vec4 other) {
vec3 midPoint = mix(pos.xyz, other.xyz, 0.5);
float distanceToCamera = length(midPoint);
float screenToWorldRatio = perRenderPixelRatio * distanceToCamera * 0.5;
float worldMarkerSize = getScreenMarkerSize() * screenToWorldRatio;
float segmentLen = length(pos.xyz - other.xyz);
return worldMarkerSize > maxSegmentLengthFraction * segmentLen;
}
float getWorldMarkerSize(vec4 pos) {
float distanceToCamera = length(pos.xyz);
float screenToWorldRatio = perRenderPixelRatio * distanceToCamera * 0.5;
return getScreenMarkerSize() * screenToWorldRatio;
}`))}var ot;(function(e){e[e.BUTT=0]="BUTT",e[e.SQUARE=1]="SQUARE",e[e.ROUND=2]="ROUND",e[e.COUNT=3]="COUNT"})(ot||(ot={}));let H=class extends la{constructor(){super(...arguments),this.output=M.Color,this.capType=ot.BUTT,this.transparencyPassType=Ue.NONE,this.occluder=!1,this.hasSlicePlane=!1,this.hasPolygonOffset=!1,this.writeDepth=!1,this.draped=!1,this.stippleEnabled=!1,this.stippleOffColorEnabled=!1,this.stipplePreferContinuous=!0,this.roundJoins=!1,this.applyMarkerOffset=!1,this.vvSize=!1,this.vvColor=!1,this.vvOpacity=!1,this.falloffEnabled=!1,this.innerColorEnabled=!1,this.hasOccludees=!1,this.multipassEnabled=!1,this.cullAboveGround=!1,this.wireframe=!1,this.objectAndLayerIdColorInstanced=!1}};m([P({count:M.COUNT})],H.prototype,"output",void 0),m([P({count:ot.COUNT})],H.prototype,"capType",void 0),m([P({count:Ue.COUNT})],H.prototype,"transparencyPassType",void 0),m([P()],H.prototype,"occluder",void 0),m([P()],H.prototype,"hasSlicePlane",void 0),m([P()],H.prototype,"hasPolygonOffset",void 0),m([P()],H.prototype,"writeDepth",void 0),m([P()],H.prototype,"draped",void 0),m([P()],H.prototype,"stippleEnabled",void 0),m([P()],H.prototype,"stippleOffColorEnabled",void 0),m([P()],H.prototype,"stipplePreferContinuous",void 0),m([P()],H.prototype,"roundJoins",void 0),m([P()],H.prototype,"applyMarkerOffset",void 0),m([P()],H.prototype,"vvSize",void 0),m([P()],H.prototype,"vvColor",void 0),m([P()],H.prototype,"vvOpacity",void 0),m([P()],H.prototype,"falloffEnabled",void 0),m([P()],H.prototype,"innerColorEnabled",void 0),m([P()],H.prototype,"hasOccludees",void 0),m([P()],H.prototype,"multipassEnabled",void 0),m([P()],H.prototype,"cullAboveGround",void 0),m([P()],H.prototype,"wireframe",void 0),m([P()],H.prototype,"objectAndLayerIdColorInstanced",void 0),m([P({constValue:!1})],H.prototype,"occlusionPass",void 0),m([P({constValue:!0})],H.prototype,"hasVvInstancing",void 0),m([P({constValue:!0})],H.prototype,"hasSliceTranslatedView",void 0);const Lr=1;function Pc(e){const t=new Mi,{attributes:r,varyings:i,constants:s,vertex:a,fragment:o}=t;t.include(Po),t.include(fc,e),t.include(wc,e);const l=e.applyMarkerOffset&&!e.draped;l&&(a.uniforms.add(new Z("markerScale",f=>f.markerScale)),t.include(Ic,{space:at.World,draped:!1})),e.output===M.LinearDepth&&t.include(Lo,e),t.include(Fo,e),No(a,e),a.uniforms.add(new Ft("inverseProjectionMatrix",(f,_)=>_.camera.inverseProjectionMatrix),new Di("nearFar",(f,_)=>_.camera.nearFar),new Z("miterLimit",f=>f.join!=="miter"?0:f.miterLimit),new xr("viewport",(f,_)=>_.camera.fullViewport)),a.constants.add("LARGE_HALF_FLOAT","float",65500),r.add(y.POSITION,"vec3"),r.add(y.PREVPOSITION,"vec3"),r.add(y.NEXTPOSITION,"vec3"),r.add(y.SUBDIVISIONFACTOR,"float"),r.add(y.UV0,"vec2"),i.add("vColor","vec4"),i.add("vpos","vec3"),i.add("vLineDistance","float"),i.add("vLineWidth","float"),jo(t);const c=e.multipassEnabled&&(e.output===M.Color||e.output===M.Alpha);c&&i.add("depth","float");const n=e.stippleEnabled;n&&i.add("vLineSizeInv","float"),s.add("aaWidth","float",e.stippleEnabled?0:1);const d=e.capType===ot.ROUND,h=e.stippleEnabled&&d,p=e.falloffEnabled||h;p&&i.add("vLineDistanceNorm","float"),d&&(i.add("vSegmentSDF","float"),i.add("vReverseSegmentSDF","float")),a.code.add(w`#define PERPENDICULAR(v) vec2(v.y, -v.x);
float interp(float ncp, vec4 a, vec4 b) {
return (-ncp - a.z) / (b.z - a.z);
}
vec2 rotate(vec2 v, float a) {
float s = sin(a);
float c = cos(a);
mat2 m = mat2(c, -s, s, c);
return m * v;
}`),a.code.add(w`vec4 projectAndScale(vec4 pos) {
vec4 posNdc = proj * pos;
posNdc.xy *= viewport.zw / posNdc.w;
return posNdc;
}`),zo(t),a.code.add(w`
    void clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next, in bool isStartVertex) {
      float vnp = nearFar[0] * 0.99;

      if(pos.z > -nearFar[0]) {
        //current pos behind ncp --> we need to clip
        if (!isStartVertex) {
          if(prev.z < -nearFar[0]) {
            //previous in front of ncp
            pos = mix(prev, pos, interp(vnp, prev, pos));
            next = pos;
          } else {
            pos = vec4(0.0, 0.0, 0.0, 1.0);
          }
        } else {
          if(next.z < -nearFar[0]) {
            //next in front of ncp
            pos = mix(pos, next, interp(vnp, pos, next));
            prev = pos;
          } else {
            pos = vec4(0.0, 0.0, 0.0, 1.0);
          }
        }
      } else {
        //current position visible
        if (prev.z > -nearFar[0]) {
          //previous behind ncp
          prev = mix(pos, prev, interp(vnp, pos, prev));
        }
        if (next.z > -nearFar[0]) {
          //next behind ncp
          next = mix(next, pos, interp(vnp, next, pos));
        }
      }

      ${c?"depth = pos.z;":""}
      linearDepth = calculateLinearDepth(nearFar,pos.z);

      pos = projectAndScale(pos);
      next = projectAndScale(next);
      prev = projectAndScale(prev);
    }
  `),Ei(a),a.code.add(w`
  void main(void) {
    // unpack values from uv0.y
    bool isStartVertex = abs(abs(uv0.y)-3.0) == 1.0;

    float coverage = 1.0;

    // Check for special value of uv0.y which is used by the Renderer when graphics
    // are removed before the VBO is recompacted. If this is the case, then we just
    // project outside of clip space.
    if (uv0.y == 0.0) {
      // Project out of clip space
      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
    }
    else {
      bool isJoin = abs(uv0.y) < 3.0;
      float lineSize = getSize();

      if (lineSize < 1.0) {
        coverage = lineSize; // convert sub-pixel coverage to alpha
        lineSize = 1.0;
      }
      lineSize += aaWidth;

      float lineWidth = lineSize * pixelRatio;
      vLineWidth = lineWidth;
      ${n?w`vLineSizeInv = 1.0 / lineSize;`:""}

      vec4 pos  = view * vec4(position, 1.0);
      vec4 prev = view * vec4(prevPosition, 1.0);
      vec4 next = view * vec4(nextPosition, 1.0);
  `),l&&a.code.add(w`vec4 other = isStartVertex ? next : prev;
bool markersHidden = areWorldMarkersHidden(pos, other);
if(!isJoin && !markersHidden) {
pos.xyz += normalize(other.xyz - pos.xyz) * getWorldMarkerSize(pos) * 0.5;
}`),a.code.add(w`clipAndTransform(pos, prev, next, isStartVertex);
vec2 left = (pos.xy - prev.xy);
vec2 right = (next.xy - pos.xy);
float leftLen = length(left);
float rightLen = length(right);`),(e.stippleEnabled||d)&&a.code.add(w`
      float isEndVertex = float(!isStartVertex);
      vec2 segmentOrigin = mix(pos.xy, prev.xy, isEndVertex);
      vec2 segment = mix(right, left, isEndVertex);
      ${d?w`vec2 segmentEnd = mix(next.xy, pos.xy, isEndVertex);`:""}
    `),a.code.add(w`left = (leftLen > 0.001) ? left/leftLen : vec2(0.0, 0.0);
right = (rightLen > 0.001) ? right/rightLen : vec2(0.0, 0.0);
vec2 capDisplacementDir = vec2(0, 0);
vec2 joinDisplacementDir = vec2(0, 0);
float displacementLen = lineWidth;
if (isJoin) {
bool isOutside = (left.x * right.y - left.y * right.x) * uv0.y > 0.0;
joinDisplacementDir = normalize(left + right);
joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);
if (leftLen > 0.001 && rightLen > 0.001) {
float nDotSeg = dot(joinDisplacementDir, left);
displacementLen /= length(nDotSeg * left - joinDisplacementDir);
if (!isOutside) {
displacementLen = min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));
}
}
if (isOutside && (displacementLen > miterLimit * lineWidth)) {`),e.roundJoins?a.code.add(w`
        vec2 startDir = leftLen < 0.001 ? right : left;
        startDir = PERPENDICULAR(startDir);

        vec2 endDir = rightLen < 0.001 ? left : right;
        endDir = PERPENDICULAR(endDir);

        float factor = ${e.stippleEnabled?w`min(1.0, subdivisionFactor * ${w.float((Lr+2)/(Lr+1))})`:w`subdivisionFactor`};

        float rotationAngle = acos(clamp(dot(startDir, endDir), -1.0, 1.0));
        joinDisplacementDir = rotate(startDir, -sign(uv0.y) * factor * rotationAngle);
      `):a.code.add(w`if (leftLen < 0.001) {
joinDisplacementDir = right;
}
else if (rightLen < 0.001) {
joinDisplacementDir = left;
}
else {
joinDisplacementDir = (isStartVertex || subdivisionFactor > 0.0) ? right : left;
}
joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);`);const u=e.capType!==ot.BUTT;return a.code.add(w`
        displacementLen = lineWidth;
      }
    } else {
      // CAP handling ---------------------------------------------------
      joinDisplacementDir = isStartVertex ? right : left;
      joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);

      ${u?w`capDisplacementDir = isStartVertex ? -right : left;`:""}
    }
  `),a.code.add(w`
    // Displacement (in pixels) caused by join/or cap
    vec2 dpos = joinDisplacementDir * sign(uv0.y) * displacementLen + capDisplacementDir * displacementLen;
    float lineDistNorm = sign(uv0.y) * pos.w;

    vLineDistance =  lineWidth * lineDistNorm;
    ${p?w`vLineDistanceNorm = lineDistNorm;`:""}

    pos.xy += dpos;
  `),d&&a.code.add(w`vec2 segmentDir = normalize(segment);
vSegmentSDF = (isJoin && isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentOrigin, segmentDir) * pos.w) ;
vReverseSegmentSDF = (isJoin && !isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentEnd, -segmentDir) * pos.w);`),e.stippleEnabled&&(e.draped?a.uniforms.add(new Z("worldToScreenRatio",(f,_)=>1/_.screenToPCSRatio)):a.code.add(w`vec3 segmentCenter = mix((nextPosition + position) * 0.5, (position + prevPosition) * 0.5, isEndVertex);
float worldToScreenRatio = computeWorldToScreenRatio(segmentCenter);`),a.code.add(w`float segmentLengthScreenDouble = length(segment);
float segmentLengthScreen = segmentLengthScreenDouble * 0.5;
float discreteWorldToScreenRatio = discretizeWorldToScreenRatio(worldToScreenRatio);
float segmentLengthRender = length(mix(nextPosition - position, position - prevPosition, isEndVertex));
vStipplePatternStretch = worldToScreenRatio / discreteWorldToScreenRatio;`),e.draped?a.code.add(w`float segmentLengthPseudoScreen = segmentLengthScreen / pixelRatio * discreteWorldToScreenRatio / worldToScreenRatio;
float startPseudoScreen = uv0.x * discreteWorldToScreenRatio - mix(0.0, segmentLengthPseudoScreen, isEndVertex);`):a.code.add(w`float startPseudoScreen = mix(uv0.x, uv0.x - segmentLengthRender, isEndVertex) * discreteWorldToScreenRatio;
float segmentLengthPseudoScreen = segmentLengthRender * discreteWorldToScreenRatio;`),a.uniforms.add(new Z("stipplePatternPixelSize",f=>Ma(f))),a.code.add(w`float patternLength = lineSize * stipplePatternPixelSize;
vStippleDistanceLimits = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, segmentLengthScreen, patternLength);
vStippleDistance = mix(vStippleDistanceLimits.x, vStippleDistanceLimits.y, isEndVertex);
if (segmentLengthScreenDouble >= 0.001) {
vec2 stippleDisplacement = pos.xy - segmentOrigin;
float stippleDisplacementFactor = dot(segment, stippleDisplacement) / (segmentLengthScreenDouble * segmentLengthScreenDouble);
vStippleDistance += (stippleDisplacementFactor - isEndVertex) * (vStippleDistanceLimits.y - vStippleDistanceLimits.x);
}
vStippleDistanceLimits *= pos.w;
vStippleDistance *= pos.w;
vStippleDistanceLimits = isJoin ?
vStippleDistanceLimits :
isStartVertex ?
vec2(-1e34, vStippleDistanceLimits.y) :
vec2(vStippleDistanceLimits.x, 1e34);`)),a.code.add(w`
      // Convert back into NDC
      pos.xy = (pos.xy / viewport.zw) * pos.w;

      vColor = getColor();
      vColor.a *= coverage;

      ${e.wireframe&&!e.draped?"pos.z -= 0.001 * pos.w;":""}

      // transform final position to camera space for slicing
      vpos = (inverseProjectionMatrix * pos).xyz;
      gl_Position = pos;
      forwardObjectAndLayerIdColor();
    }
  }
  `),c&&t.include(Vo,e),t.include(Uo,e),o.include(Ho),o.code.add(w`
  void main() {
    discardBySlice(vpos);
    ${c?"terrainDepthTest(depth);":""}
  `),e.wireframe?o.code.add(w`vec4 finalColor = vec4(1.0, 0.0, 1.0, 1.0);`):(d&&o.code.add(w`
        float sdf = min(vSegmentSDF, vReverseSegmentSDF);
        vec2 fragmentPosition = vec2(
          min(sdf, 0.0),
          vLineDistance
        ) * gl_FragCoord.w;

        float fragmentRadius = length(fragmentPosition);
        float fragmentCapSDF = (fragmentRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale
        float capCoverage = clamp(0.5 - fragmentCapSDF, 0.0, 1.0);

        if (capCoverage < ${w.float(kr)}) {
          discard;
        }
      `),h?o.code.add(w`
      vec2 stipplePosition = vec2(
        min(getStippleSDF() * 2.0 - 1.0, 0.0),
        vLineDistanceNorm * gl_FragCoord.w
      );
      float stippleRadius = length(stipplePosition * vLineWidth);
      float stippleCapSDF = (stippleRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale
      float stippleCoverage = clamp(0.5 - stippleCapSDF, 0.0, 1.0);
      float stippleAlpha = step(${w.float(kr)}, stippleCoverage);
      `):o.code.add(w`float stippleAlpha = getStippleAlpha();`),e.output!==M.ObjectAndLayerIdColor&&o.code.add(w`discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);`),o.uniforms.add(new xr("intrinsicColor",f=>f.color)),o.code.add(w`vec4 color = intrinsicColor * vColor;`),e.innerColorEnabled&&(o.uniforms.add(new xr("innerColor",f=>f.innerColor??f.color),new Z("innerWidth",(f,_)=>f.innerWidth*_.camera.pixelRatio)),o.code.add(w`float distToInner = abs(vLineDistance * gl_FragCoord.w) - innerWidth;
float innerAA = clamp(0.5 - distToInner, 0.0, 1.0);
float innerAlpha = innerColor.a + color.a * (1.0 - innerColor.a);
color = mix(color, vec4(innerColor.rgb, innerAlpha), innerAA);`)),o.code.add(w`vec4 finalColor = blendStipple(color, stippleAlpha);`),e.falloffEnabled&&(o.uniforms.add(new Z("falloff",f=>f.falloff)),o.code.add(w`finalColor.a *= pow(max(0.0, 1.0 - abs(vLineDistanceNorm * gl_FragCoord.w)), falloff);`)),e.stippleEnabled||o.code.add(w`float featherStartDistance = max(vLineWidth - 2.0, 0.0);
float value = abs(vLineDistance) * gl_FragCoord.w;
float feather = (value - featherStartDistance) / (vLineWidth - featherStartDistance);
finalColor.a *= 1.0 - clamp(feather, 0.0, 1.0);`)),o.code.add(w`
    ${e.output===M.ObjectAndLayerIdColor?w`finalColor.a = 1.0;`:""}

    if (finalColor.a < ${w.float(kr)}) {
      discard;
    }

    ${e.output===M.Alpha?w`fragColor = vec4(finalColor.a);`:""}
    ${e.output===M.Color?w`fragColor = highlightSlice(finalColor, vpos);`:""}
    ${e.output===M.Color&&e.transparencyPassType===Ue.Color?"fragColor = premultiplyAlpha(fragColor);":""}
    ${e.output===M.Highlight?w`fragColor = vec4(1.0);`:""}
    ${e.output===M.LinearDepth?w`outputDepth(linearDepth);`:""}
    ${e.output===M.ObjectAndLayerIdColor?w`outputObjectAndLayerIdColor();`:""}
  }
  `),t}const Lc=Object.freeze(Object.defineProperty({__proto__:null,build:Pc,ribbonlineNumRoundJoinSubdivisions:Lr},Symbol.toStringTag,{value:"Module"})),Va=new Map([[y.POSITION,0],[y.PREVPOSITION,1],[y.NEXTPOSITION,2],[y.SUBDIVISIONFACTOR,3],[y.UV0,4],[y.COLOR,5],[y.COLORFEATUREATTRIBUTE,5],[y.SIZE,6],[y.SIZEFEATUREATTRIBUTE,6],[y.OPACITYFEATUREATTRIBUTE,7],[y.OBJECTANDLAYERIDCOLOR,8]]);let Ua=class Ha extends Ii{initializeProgram(t){return new Pi(t.rctx,Ha.shader.get().build(this.configuration),Va)}_makePipelineState(t,r){const i=this.configuration,s=t===Ue.NONE,a=t===Ue.FrontFace,o=Go(i.output);return tt({blending:i.output===M.Color||i.output===M.Alpha?s?Qr:zn(t):null,depthTest:{func:Vn(t)},depthWrite:s?i.writeDepth||o?Un:null:Hn(t),colorWrite:Et,stencilWrite:i.hasOccludees?is:null,stencilTest:i.hasOccludees?r?ss:Wo:null,polygonOffset:s||a?i.hasPolygonOffset?$s:null:Gn})}initializePipeline(){const t=this.configuration;if(t.occluder){const r=t.hasPolygonOffset?$s:null;this._occluderPipelineTransparent=tt({blending:Qr,polygonOffset:r,depthTest:as,depthWrite:null,colorWrite:Et,stencilWrite:null,stencilTest:Bo}),this._occluderPipelineOpaque=tt({blending:Qr,polygonOffset:r,depthTest:as,depthWrite:null,colorWrite:Et,stencilWrite:ko,stencilTest:qo}),this._occluderPipelineMaskWrite=tt({blending:null,polygonOffset:r,depthTest:Zo,depthWrite:null,colorWrite:null,stencilWrite:is,stencilTest:ss})}return this._occludeePipelineState=this._makePipelineState(this.configuration.transparencyPassType,!0),this._makePipelineState(this.configuration.transparencyPassType,!1)}get primitiveType(){return this.configuration.wireframe?_s.LINES:_s.TRIANGLE_STRIP}getPipeline(t,r,i){return t?this._occludeePipelineState:this.configuration.occluder?i?this._occluderPipelineTransparent:r?this._occluderPipelineOpaque:this._occluderPipelineMaskWrite:super.getPipeline()}};Ua.shader=new $i(Lc,()=>bi(()=>import("./ColorMaterial.glsl-uPKQoFFi.js").then(e=>e.R),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30])));const $s={factor:0,units:-4};var me;(function(e){e[e.LEFT_JOIN_START=-2]="LEFT_JOIN_START",e[e.LEFT_JOIN_END=-1]="LEFT_JOIN_END",e[e.LEFT_CAP_START=-4]="LEFT_CAP_START",e[e.LEFT_CAP_END=-5]="LEFT_CAP_END",e[e.RIGHT_JOIN_START=2]="RIGHT_JOIN_START",e[e.RIGHT_JOIN_END=1]="RIGHT_JOIN_END",e[e.RIGHT_CAP_START=4]="RIGHT_CAP_START",e[e.RIGHT_CAP_END=5]="RIGHT_CAP_END"})(me||(me={}));class Fc extends Tn{constructor(t){super(t,new jc),this._configuration=new H,this.produces=new Map([[ie.OPAQUE_MATERIAL,r=>r===M.Highlight||r===M.ObjectAndLayerIdColor||(r===M.Color||r===M.Alpha)&&this.parameters.renderOccluded===Oe.OccludeAndTransparentStencil],[ie.OPAQUE_NO_SSAO_DEPTH,r=>r===M.LinearDepth],[ie.OCCLUDER_MATERIAL,r=>os(r)&&this.parameters.renderOccluded===Oe.OccludeAndTransparentStencil],[ie.TRANSPARENT_OCCLUDER_MATERIAL,r=>os(r)&&this.parameters.renderOccluded===Oe.OccludeAndTransparentStencil],[ie.TRANSPARENT_MATERIAL,r=>(r===M.Color||r===M.Alpha)&&this.parameters.writeDepth&&this.parameters.renderOccluded!==Oe.OccludeAndTransparentStencil],[ie.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL,r=>(r===M.Color||r===M.Alpha)&&!this.parameters.writeDepth&&this.parameters.renderOccluded!==Oe.OccludeAndTransparentStencil],[ie.DRAPED_MATERIAL,r=>Qo(r)]]),this._vertexAttributeLocations=Va}getConfiguration(t,r){this._configuration.output=t,this._configuration.draped=r.slot===ie.DRAPED_MATERIAL;const i=this.parameters.stipplePattern!=null&&t!==M.Highlight;return this._configuration.stippleEnabled=i,this._configuration.stippleOffColorEnabled=i&&this.parameters.stippleOffColor!=null,this._configuration.stipplePreferContinuous=i&&this.parameters.stipplePreferContinuous,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasOccludees=this.parameters.hasOccludees,this._configuration.roundJoins=this.parameters.join==="round",this._configuration.capType=this.parameters.cap,this._configuration.applyMarkerOffset=this.parameters.markerParameters!=null&&Vc(this.parameters.markerParameters),this._configuration.hasPolygonOffset=this.parameters.hasPolygonOffset,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.vvOpacity=!!this.parameters.vvOpacity,this._configuration.innerColorEnabled=this.parameters.innerWidth>0&&this.parameters.innerColor!=null,this._configuration.falloffEnabled=this.parameters.falloff>0,this._configuration.occluder=this.parameters.renderOccluded===Oe.OccludeAndTransparentStencil,this._configuration.transparencyPassType=r.transparencyPassType,this._configuration.multipassEnabled=r.multipassEnabled,this._configuration.cullAboveGround=r.multipassTerrain.cullAboveGround,this._configuration.wireframe=this.parameters.wireframe,this._configuration}intersectDraped(t,r,i,s,a,o){if(!i.options.selectionMode)return;const l=t.attributes.get(y.POSITION).data,c=t.attributes.get(y.SIZE);let n=this.parameters.width;if(this.parameters.vvSize){const _=t.attributes.get(y.SIZEFEATUREATTRIBUTE).data[0];n*=Dt(this.parameters.vvSize.offset[0]+_*this.parameters.vvSize.factor[0],this.parameters.vvSize.minSize[0],this.parameters.vvSize.maxSize[0])}else c&&(n*=c.data[0]);const d=s[0],h=s[1],p=(n/2+4)*t.screenToWorldRatio;let u=Number.MAX_VALUE,f=0;for(let _=0;_<l.length-5;_+=3){const x=l[_],T=l[_+1],S=d-x,v=h-T,O=l[_+3]-x,C=l[_+4]-T,A=Dt((O*S+C*v)/(O*O+C*C),0,1),g=O*A-S,U=C*A-v,V=g*g+U*U;V<u&&(u=V,f=_/3)}u<p*p&&a(o.dist,o.normal,f,!1)}intersect(t,r,i,s,a,o){if(!i.options.selectionMode||!t.visible)return;if(!fn(r))return void zr.getLogger("esri.views.3d.webgl-engine.materials.RibbonLineMaterial").error("intersection assumes a translation-only matrix");const l=t.attributes,c=l.get(y.POSITION).data;let n=this.parameters.width;if(this.parameters.vvSize){const S=l.get(y.SIZEFEATUREATTRIBUTE).data[0];n*=Dt(this.parameters.vvSize.offset[0]+S*this.parameters.vvSize.factor[0],this.parameters.vvSize.minSize[0],this.parameters.vvSize.maxSize[0])}else l.has(y.SIZE)&&(n*=l.get(y.SIZE).data[0]);const d=i.camera,h=Uc;Ni(h,i.point);const p=n*d.pixelRatio/2+4*d.pixelRatio;Q(Vt[0],h[0]-p,h[1]+p,0),Q(Vt[1],h[0]+p,h[1]+p,0),Q(Vt[2],h[0]+p,h[1]-p,0),Q(Vt[3],h[0]-p,h[1]-p,0);for(let S=0;S<4;S++)if(!d.unprojectFromRenderScreen(Vt[S],ze[S]))return;nr(d.eye,ze[0],ze[1],ii),nr(d.eye,ze[1],ze[2],si),nr(d.eye,ze[2],ze[3],ai),nr(d.eye,ze[3],ze[0],oi);let u=Number.MAX_VALUE,f=0;const _=Ga(this.parameters,l)?c.length-2:c.length-5;for(let S=0;S<_;S+=3){de[0]=c[S]+r[12],de[1]=c[S+1]+r[13],de[2]=c[S+2]+r[14];const v=(S+3)%c.length;if(he[0]=c[v]+r[12],he[1]=c[v+1]+r[13],he[2]=c[v+2]+r[14],Me(ii,de)<0&&Me(ii,he)<0||Me(si,de)<0&&Me(si,he)<0||Me(ai,de)<0&&Me(ai,he)<0||Me(oi,de)<0&&Me(oi,he)<0)continue;if(d.projectToRenderScreen(de,Qe),d.projectToRenderScreen(he,Je),Qe[2]<0&&Je[2]>0){ae(Ee,de,he);const C=d.frustum,A=-Me(C[dr.NEAR],de)/Lt(Ee,ns(C[dr.NEAR]));se(Ee,Ee,A),le(de,de,Ee),d.projectToRenderScreen(de,Qe)}else if(Qe[2]>0&&Je[2]<0){ae(Ee,he,de);const C=d.frustum,A=-Me(C[dr.NEAR],he)/Lt(Ee,ns(C[dr.NEAR]));se(Ee,Ee,A),le(he,he,Ee),d.projectToRenderScreen(he,Je)}else if(Qe[2]<0&&Je[2]<0)continue;Qe[2]=0,Je[2]=0;const O=Fn(Zr(Qe,Je,Ls),h);O<u&&(u=O,X(Is,de),X(Ps,he),f=S/3)}const x=i.rayBegin,T=i.rayEnd;if(u<p*p){let S=Number.MAX_VALUE;if(Nn(Zr(Is,Ps,Ls),Zr(x,T,Hc),Ze)){ae(Ze,Ze,x);const v=Jt(Ze);se(Ze,Ze,1/v),S=v/jr(x,T)}o(S,Ze,f,!1)}}get _layout(){const t=jn().vec3f(y.POSITION).vec3f(y.PREVPOSITION).vec3f(y.NEXTPOSITION).f32(y.SUBDIVISIONFACTOR).vec2f(y.UV0);return this.parameters.vvSize?t.f32(y.SIZEFEATUREATTRIBUTE):t.f32(y.SIZE),this.parameters.vvColor?t.f32(y.COLORFEATUREATTRIBUTE):t.vec4f(y.COLOR),this.parameters.vvOpacity&&t.f32(y.OPACITYFEATUREATTRIBUTE),Mt("enable-feature:objectAndLayerId-rendering")&&t.vec4u8(y.OBJECTANDLAYERIDCOLOR),t}createBufferWriter(){return new zc(this._layout,this.parameters)}createGLMaterial(t){return new Nc(t)}validateParameters(t){t.join!=="miter"&&(t.miterLimit=0),t.markerParameters!=null&&(t.markerScale=t.markerParameters.width/t.width)}}let Nc=class extends Jo{constructor(){super(...arguments),this._stipplePattern=null}dispose(){super.dispose(),this._stippleTextureRepository.release(this._stipplePattern),this._stipplePattern=null}_updateOccludeeState(t){t.hasOccludees!==this._material.parameters.hasOccludees&&this._material.setParameters({hasOccludees:t.hasOccludees})}beginSlot(t){this._output!==M.Color&&this._output!==M.Alpha||this._updateOccludeeState(t);const r=this._material.parameters.stipplePattern;return this._stipplePattern!==r&&(this._material.setParameters({stippleTexture:this._stippleTextureRepository.swap(r,this._stipplePattern)}),this._stipplePattern=r),this.ensureTechnique(Ua,t)}},jc=class extends Yo{constructor(){super(...arguments),this.width=0,this.color=fo,this.join="miter",this.cap=ot.BUTT,this.miterLimit=5,this.writeDepth=!0,this.hasPolygonOffset=!1,this.stippleTexture=null,this.stipplePreferContinuous=!0,this.markerParameters=null,this.markerScale=1,this.hasSlicePlane=!1,this.vvFastUpdate=!1,this.isClosed=!1,this.falloff=0,this.innerWidth=0,this.hasOccludees=!1,this.wireframe=!1}},zc=class{constructor(t,r){this.vertexBufferLayout=t,this._parameters=r,this.numJoinSubdivisions=0;const i=r.stipplePattern?1:0;switch(this._parameters.join){case"miter":case"bevel":this.numJoinSubdivisions=i;break;case"round":this.numJoinSubdivisions=Lr+i}}_isClosed(t){return Ga(this._parameters,t.attributes)}allocate(t){return this.vertexBufferLayout.createBuffer(t)}elementCount(t){const i=t.attributes.get(y.POSITION).indices.length/2+1,s=this._isClosed(t);let a=s?2:2*2;return a+=((s?i:i-1)-(s?0:1))*(2*this.numJoinSubdivisions+4),a+=2,this._parameters.wireframe&&(a=2+4*(a-2)),a}write(t,r,i,s,a){var nt,sr,$;const o=Gc,l=Wc,c=Bc,n=i.attributes.get(y.POSITION),d=n.indices,h=n.data.length/3,p=(nt=i.attributes.get(y.DISTANCETOSTART))==null?void 0:nt.data;d&&d.length!==2*(h-1)&&console.warn("RibbonLineMaterial does not support indices");const u=((sr=i.attributes.get(y.SIZEFEATUREATTRIBUTE))==null?void 0:sr.data[0])??(($=i.attributes.get(y.SIZE))==null?void 0:$.data[0])??1;let f=[1,1,1,1],_=0;const x=this.vertexBufferLayout.fields.has(y.COLORFEATUREATTRIBUTE);x?_=i.attributes.get(y.COLORFEATUREATTRIBUTE).data[0]:i.attributes.has(y.COLOR)&&(f=i.attributes.get(y.COLOR).data);const T=Mt("enable-feature:objectAndLayerId-rendering")?i.objectAndLayerIdColor:null,S=this.vertexBufferLayout.fields.has(y.OPACITYFEATUREATTRIBUTE),v=S?i.attributes.get(y.OPACITYFEATUREATTRIBUTE).data[0]:0,O=new Float32Array(s.buffer),C=Mt("enable-feature:objectAndLayerId-rendering")?new Uint8Array(s.buffer):null,A=this.vertexBufferLayout.stride/4;let g=a*A;const U=g;let V=0;const D=p?(B,K,ge)=>V=p[ge]:(B,K,ge)=>V+=jr(B,K),ce=Mt("enable-feature:objectAndLayerId-rendering"),N=(B,K,ge,je,lt,Ja,Ya)=>{if(O[g++]=K[0],O[g++]=K[1],O[g++]=K[2],O[g++]=B[0],O[g++]=B[1],O[g++]=B[2],O[g++]=ge[0],O[g++]=ge[1],O[g++]=ge[2],O[g++]=je,O[g++]=Ya,O[g++]=lt,O[g++]=u,x)O[g++]=_;else{const ar=Math.min(4*Ja,f.length-4);O[g++]=f[ar],O[g++]=f[ar+1],O[g++]=f[ar+2],O[g++]=f[ar+3]}S&&(O[g++]=v),ce&&(T!=null&&(C[4*g]=T[0],C[4*g+1]=T[1],C[4*g+2]=T[2],C[4*g+3]=T[3]),g++)};g+=A,Q(l,n.data[0],n.data[1],n.data[2]),t&&ye(l,l,t);const Fe=this._isClosed(i);if(Fe){const B=n.data.length-3;Q(o,n.data[B],n.data[B+1],n.data[B+2]),t&&ye(o,o,t)}else Q(c,n.data[3],n.data[4],n.data[5]),t&&ye(c,c,t),N(l,l,c,1,me.LEFT_CAP_START,0,0),N(l,l,c,1,me.RIGHT_CAP_START,0,0),X(o,l),X(l,c);const jt=Fe?0:1,Ne=Fe?h:h-1;for(let B=jt;B<Ne;B++){const K=(B+1)%h*3;Q(c,n.data[K],n.data[K+1],n.data[K+2]),t&&ye(c,c,t),D(o,l,B),N(o,l,c,0,me.LEFT_JOIN_END,B,V),N(o,l,c,0,me.RIGHT_JOIN_END,B,V);const ge=this.numJoinSubdivisions;for(let je=0;je<ge;++je){const lt=(je+1)/(ge+1);N(o,l,c,lt,me.LEFT_JOIN_END,B,V),N(o,l,c,lt,me.RIGHT_JOIN_END,B,V)}N(o,l,c,1,me.LEFT_JOIN_START,B,V),N(o,l,c,1,me.RIGHT_JOIN_START,B,V),X(o,l),X(l,c)}Fe?(Q(c,n.data[3],n.data[4],n.data[5]),t&&ye(c,c,t),V=D(o,l,Ne),N(o,l,c,0,me.LEFT_JOIN_END,jt,V),N(o,l,c,0,me.RIGHT_JOIN_END,jt,V)):(V=D(o,l,Ne),N(o,l,l,0,me.LEFT_CAP_END,Ne,V),N(o,l,l,0,me.RIGHT_CAP_END,Ne,V)),ri(O,U+A,O,U,A),g=ri(O,g-A,O,g,A),this._parameters.wireframe&&this._addWireframeVertices(s,U,g,A)}_addWireframeVertices(t,r,i,s){const a=new Float32Array(t.buffer,i*Float32Array.BYTES_PER_ELEMENT),o=new Float32Array(t.buffer,r*Float32Array.BYTES_PER_ELEMENT,i-r);let l=0;const c=n=>l=ri(o,n,a,l,s);for(let n=0;n<o.length-1;n+=2*s)c(n),c(n+2*s),c(n+1*s),c(n+2*s),c(n+1*s),c(n+3*s)}};function ri(e,t,r,i,s){for(let a=0;a<s;a++)r[i++]=e[t++];return i}function Ga(e,t){return e.isClosed?t.get(y.POSITION).indices.length>2:!1}function Vc(e){return e.anchor===er.Tip&&e.hideOnShortSegments&&e.placement==="begin-end"&&e.worldSpace}const de=E(),he=E(),Ee=E(),Ze=E(),Uc=E(),Qe=Ke(),Je=Ke(),Is=E(),Ps=E(),Ls=_a(),Hc=_a(),Gc=E(),Wc=E(),Bc=E(),Vt=[Ke(),Ke(),Ke(),Ke()],ze=[E(),E(),E(),E()],ii=rr(),si=rr(),ai=rr(),oi=rr();class kc{constructor(t){this._originSR=t,this._rootOriginId="root/"+Oi(),this._origins=new Map,this._objects=new Map,this._gridSize=5e5}getOrigin(t){const r=this._origins.get(this._rootOriginId);if(r==null){const d=Si(t[0]+Math.random()-.5,t[1]+Math.random()-.5,t[2]+Math.random()-.5,this._rootOriginId);return this._origins.set(this._rootOriginId,d),d}const i=this._gridSize,s=Math.round(t[0]/i),a=Math.round(t[1]/i),o=Math.round(t[2]/i),l=`${s}/${a}/${o}`;let c=this._origins.get(l);const n=.5*i;if(ae(te,t,r.vec3),te[0]=Math.abs(te[0]),te[1]=Math.abs(te[1]),te[2]=Math.abs(te[2]),te[0]<n&&te[1]<n&&te[2]<n){if(c){const d=Math.max(...te);if(ae(te,t,c.vec3),te[0]=Math.abs(te[0]),te[1]=Math.abs(te[1]),te[2]=Math.abs(te[2]),Math.max(...te)<d)return c}return r}return c||(c=Si(s*i,a*i,o*i,l),this._origins.set(l,c)),c}_drawOriginBox(t,r=fi(1,1,0,1)){const i=window.view,s=i._stage,a=r.toString();if(!this._objects.has(a)){this._material=new Fc({width:2,color:r}),s.add(this._material);const u=new pc(s,{pickable:!1}),f=new kl({castShadow:!1});s.add(f),u.add(f),this._objects.set(a,f)}const o=this._objects.get(a),l=[0,1,5,4,0,2,1,7,6,2,0,1,3,7,5,4,6,2,0],c=l.length,n=new Array(3*c),d=new Array,h=.5*this._gridSize;for(let u=0;u<c;u++)n[3*u]=t[0]+(1&l[u]?h:-h),n[3*u+1]=t[1]+(2&l[u]?h:-h),n[3*u+2]=t[2]+(4&l[u]?h:-h),u>0&&d.push(u-1,u);mi(n,this._originSR,0,n,i.renderSpatialReference,0,c);const p=new we(this._material,[[y.POSITION,new j(n,d,3,!0)]],null,Nt.Line);s.add(p),o.addGeometry(p)}get test(){const t=this;return{set gridSize(r){t._gridSize=r}}}}const te=E();let Wa=class{constructor(t,r,i=null){this.rctx=t,this.sliceHelper=i,this.lastFrameCamera=new I,this.output=M.Color,this.renderOccludedMask=Ti,this.bindParameters=new vl(r,i!=null?i.plane:null),this.bindParameters.alignPixelEnabled=!0}},$u=class extends Wa{constructor(t,r,i,s){super(t,i,s),this.offscreenRenderingHelper=r,this.sliceHelper=s,this.time=mo(0)}};const Ti=Oe.Occlude|Oe.OccludeAndTransparent|Oe.OccludeAndTransparentStencil;let Bt=class extends I{constructor(){super(...arguments),this._projectionMatrix=W()}get projectionMatrix(){return this._projectionMatrix}};m([b()],Bt.prototype,"_projectionMatrix",void 0),m([b({readOnly:!0})],Bt.prototype,"projectionMatrix",null),Bt=m([tr("esri.views.3d.webgl-engine.lib.CascadeCamera")],Bt);var Ri;(function(e){e[e.Highlight=0]="Highlight",e[e.ExcludeHighlight=1]="ExcludeHighlight"})(Ri||(Ri={}));let pr=class{constructor(){this.camera=new Bt,this.lightMat=W()}},qc=class{constructor(){this.maxNumCascadesHighQuality=4,this.maxNumCascadesLowQuality=4,this.textureSizeModHighQuality=1.3,this.textureSizeModLowQuality=.9,this.splitSchemeLambda=0}};class Zc{constructor(t,r){this._fbos=t,this._viewingMode=r,this._enabled=!1,this._snapshots=new Array,this._textureHeight=0,this._numCascades=1,this.settings=new qc,this._projectionView=W(),this._projectionViewInverse=W(),this._modelViewLight=W(),this._cascadeDistances=[0,0,0,0,0],this._usedCascadeDistances=Ve(),this._cascades=[new pr,new pr,new pr,new pr],this._lastOrigin=null,this._maxTextureWidth=Math.min(Mt("esri-mobile")?4096:16384,t.rctx.parameters.maxTextureSize)}dispose(){this.enabled=!1,this.disposeOffscreenBuffers()}get depthTexture(){var t;return(t=this._handle)==null?void 0:t.getTexture()}get _textureWidth(){return this._textureHeight*this._numCascades}get numCascades(){return this._numCascades}get cascadeDistances(){return gi(this._usedCascadeDistances,this._cascadeDistances[0],this._numCascades>1?this._cascadeDistances[1]:1/0,this._numCascades>2?this._cascadeDistances[2]:1/0,this._numCascades>3?this._cascadeDistances[3]:1/0)}disposeOffscreenBuffers(){this._handle=br(this._handle),this._discardSnapshots()}set maxCascades(t){this.settings.maxNumCascadesHighQuality=Dt(Math.floor(t),1,4)}get maxCascades(){return this.settings.maxNumCascadesHighQuality}set enabled(t){this._enabled=t,t||this.disposeOffscreenBuffers()}get enabled(){return this._enabled}get ready(){return this._enabled&&this.depthTexture!=null}get cascades(){for(let t=0;t<this._numCascades;++t)li[t]=this._cascades[t];return li.length=this._numCascades,li}start(t,r,i,s,a){pe(this.enabled);const{near:o,far:l}=this._clampNearFar(i);this._computeCascadeDistances(o,l,s),this._textureHeight=this._computeTextureHeight(t,a,s),this._setupMatrices(t,r);const{viewMatrix:c,projectionMatrix:n}=t;for(let d=0;d<this._numCascades;++d)this._constructCascade(d,n,c,r);this._lastOrigin=null,this.clear()}finish(){var t;pe(this.enabled),(t=this._handle)==null||t.detachDepth()}getShadowMapMatrices(t){if(!this._lastOrigin||!St(t,this._lastOrigin)){this._lastOrigin=this._lastOrigin||E(),X(this._lastOrigin,t);for(let r=0;r<this._numCascades;++r){Ji(Us,this._cascades[r].lightMat,t);for(let i=0;i<16;++i)Hs[16*r+i]=Us[i]}}return Hs}moveSnapshot(t){var r,i;pe(this.enabled),(r=this._handle)==null||r.detachDepth(),(i=this._snapshots[t])==null||i.release(),this._snapshots[t]=this._handle,this._handle=null,this.clear()}copySnapshot(t){var c,n,d,h;const r=(n=(c=this._handle)==null?void 0:c.getTexture())==null?void 0:n.descriptor;if(!this.enabled||!r)return;(d=this._snapshots[t])==null||d.release();const{width:i,height:s}=r,a=t===Ri.Highlight?"shadow highlight snapshot":"shadow no highlight snapshot";this._snapshots[t]=this._fbos.acquire(i,s,a,Dr.RGBA4);const o=this._fbos.rctx;this._bindFbo();const l=o.bindTexture((h=this._snapshots[t])==null?void 0:h.getTexture(),Xt.TEXTURE_UNIT_FOR_UPDATES);o.gl.copyTexSubImage2D(kn.TEXTURE_2D,0,0,0,0,0,i,s),o.bindTexture(l,Xt.TEXTURE_UNIT_FOR_UPDATES)}getSnapshot(t){var r;return this.enabled?(r=this._snapshots[t])==null?void 0:r.getTexture():null}clear(){const t=this._fbos.rctx;this._ensureFbo(),this._bindFbo(),t.setClearColor(1,1,1,1),t.clearSafe($r.COLOR_BUFFER_BIT|$r.DEPTH_BUFFER_BIT)}_computeTextureHeight(t,r,i){const s=Math.min(window.devicePixelRatio,r)/t.pixelRatio,a=i?this.settings.textureSizeModHighQuality:this.settings.textureSizeModLowQuality,o=Xo(Math.floor(Math.max(t.fullWidth,t.fullHeight)*s*a)),l=Math.min(this._maxTextureWidth,this._numCascades*o);return Ko(l/this._numCascades)}_ensureFbo(){var t,r,i,s;((t=this._handle)==null?void 0:t.fbo.width)===this._textureWidth&&((r=this._handle)==null?void 0:r.fbo.height)===this._textureHeight||((i=this._handle)==null||i.release(),this._handle=this._fbos.acquire(this._textureWidth,this._textureHeight,"shadow map",Dr.RGBA4)),(s=this._handle)==null||s.acquireDepth(en.DEPTH16_BUFFER)}_discardSnapshot(t){this._snapshots[t]=br(this._snapshots[t])}_discardSnapshots(){for(let t=0;t<this._snapshots.length;++t)this._discardSnapshot(t);this._snapshots.length=0}_bindFbo(){var r;const t=this._fbos.rctx;t.unbindTexture(this.depthTexture),t.bindFramebuffer((r=this._handle)==null?void 0:r.fbo)}_constructCascade(t,r,i,s){const a=this._cascades[t],o=-this._cascadeDistances[t],l=-this._cascadeDistances[t+1],c=(r[10]*o+r[14])/Math.abs(r[11]*o+r[15]),n=(r[10]*l+r[14])/Math.abs(r[11]*l+r[15]);pe(c<n);for(let u=0;u<8;++u){gi(Fs,u%4==0||u%4==3?-1:1,u%4==0||u%4==1?-1:1,u<4?c:n,1);const f=Ce[u];Ht(f,Fs,this._projectionViewInverse),f[0]/=f[3],f[1]/=f[3],f[2]/=f[3]}go(ni,Ce[0]),a.camera.viewMatrix=Ji(Qc,this._modelViewLight,ni);for(let u=0;u<8;++u)ye(Ce[u],Ce[u],a.camera.viewMatrix);let d=Ce[0][2],h=Ce[0][2];for(let u=1;u<8;++u)d=Math.min(d,Ce[u][2]),h=Math.max(h,Ce[u][2]);d-=200,h+=200,a.camera.near=-h,a.camera.far=-d,Kc(i,s,d,h,a.camera),Be(a.lightMat,a.camera.projectionMatrix,a.camera.viewMatrix);const p=this._textureHeight;a.camera.viewport=[t*p,0,p,p]}_setupMatrices(t,r){Be(this._projectionView,t.projectionMatrix,t.viewMatrix),kt(this._projectionViewInverse,this._projectionView);const i=this._viewingMode===Li.Global?t.eye:Q(ni,0,0,1);ta(this._modelViewLight,[0,0,0],[-r[0],-r[1],-r[2]],i)}_clampNearFar(t){let{near:r,far:i}=t;return r<2&&(r=2),i<2&&(i=2),r>=i&&(r=2,i=4),{near:r,far:i}}_computeCascadeDistances(t,r,i){const s=i?this.settings.maxNumCascadesHighQuality:this.settings.maxNumCascadesLowQuality;this._numCascades=Math.min(1+Math.floor(mn(r/t,4)),s);const a=(r-t)/this._numCascades,o=(r/t)**(1/this._numCascades);let l=t,c=t;for(let n=0;n<this._numCascades+1;++n)this._cascadeDistances[n]=Gt(l,c,this.settings.splitSchemeLambda),l*=o,c+=a}get test(){return{cascades:this._cascades,textureHeight:this._textureHeight}}}const Qc=W(),Fs=Ve(),Ce=[];for(let e=0;e<8;++e)Ce.push(Ve());const Ns=k(),js=k(),Jc=k(),zs=k(),Vs=k(),ni=E(),li=[],Us=W(),Hs=Ge.concat(Ge,Ge,Ge,Ge),ve=k(),vt=k(),Ye=[k(),k(),k(),k()],q=k(),ci=k(),He=k(),Ut=k(),yt=k(),wt=k(),fr=k();function Yc(e,t,r,i,s,a,o,l){_i(ve,0,0);for(let C=0;C<4;++C)qe(ve,ve,e[C]);xt(ve,ve,.25),_i(vt,0,0);for(let C=4;C<8;++C)qe(vt,vt,e[C]);xt(vt,vt,.25),zt(Ye[0],e[4],e[5],.5),zt(Ye[1],e[5],e[6],.5),zt(Ye[2],e[6],e[7],.5),zt(Ye[3],e[7],e[4],.5);let c=0,n=fs(Ye[0],ve);for(let C=1;C<4;++C){const A=fs(Ye[C],ve);A<n&&(n=A,c=C)}Ct(q,Ye[c],e[c+4]);const d=q[0];let h,p;q[0]=-q[1],q[1]=d,Ct(ci,vt,ve),ne(ci,q)<0&&Dn(q,q),zt(q,q,ci,r),ms(q,q),h=p=ne(Ct(He,e[0],ve),q);for(let C=1;C<8;++C){const A=ne(Ct(He,e[C],ve),q);A<h?h=A:A>p&&(p=A)}Ni(i,ve),xt(He,q,h-t),qe(i,i,He);let u=-1,f=1,_=0,x=0;for(let C=0;C<8;++C){Ct(Ut,e[C],i),ms(Ut,Ut);const A=q[0]*Ut[1]-q[1]*Ut[0];A>0?A>u&&(u=A,_=C):A<f&&(f=A,x=C)}dt(u>0,"leftArea"),dt(f<0,"rightArea"),xt(yt,q,h),qe(yt,yt,ve),xt(wt,q,p),qe(wt,wt,ve),fr[0]=-q[1],fr[1]=q[0];const T=lr(i,e[x],wt,qe(He,wt,fr),1,s),S=lr(i,e[_],wt,He,1,a),v=lr(i,e[_],yt,qe(He,yt,fr),1,o),O=lr(i,e[x],yt,He,1,l);dt(T,"rayRay"),dt(S,"rayRay"),dt(v,"rayRay"),dt(O,"rayRay")}function F(e,t){return 3*t+e}const Gs=k();function fe(e,t){return _i(Gs,e[t],e[t+3]),Gs}const ue=k(),R=Qn();function Xc(e,t,r,i,s){Ct(ue,r,i),xt(ue,ue,.5),R[0]=ue[0],R[1]=ue[1],R[2]=0,R[3]=ue[1],R[4]=-ue[0],R[5]=0,R[6]=ue[0]*ue[0]+ue[1]*ue[1],R[7]=ue[0]*ue[1]-ue[1]*ue[0],R[8]=1,R[F(0,2)]=-ne(fe(R,0),e),R[F(1,2)]=-ne(fe(R,1),e);let a=ne(fe(R,0),r)+R[F(0,2)],o=ne(fe(R,1),r)+R[F(1,2)],l=ne(fe(R,0),i)+R[F(0,2)],c=ne(fe(R,1),i)+R[F(1,2)];a=-(a+l)/(o+c),R[F(0,0)]+=R[F(1,0)]*a,R[F(0,1)]+=R[F(1,1)]*a,R[F(0,2)]+=R[F(1,2)]*a,a=1/(ne(fe(R,0),r)+R[F(0,2)]),o=1/(ne(fe(R,1),r)+R[F(1,2)]),R[F(0,0)]*=a,R[F(0,1)]*=a,R[F(0,2)]*=a,R[F(1,0)]*=o,R[F(1,1)]*=o,R[F(1,2)]*=o,R[F(2,0)]=R[F(1,0)],R[F(2,1)]=R[F(1,1)],R[F(2,2)]=R[F(1,2)],R[F(1,2)]+=1,a=ne(fe(R,1),t)+R[F(1,2)],o=ne(fe(R,2),t)+R[F(2,2)],l=ne(fe(R,1),r)+R[F(1,2)],c=ne(fe(R,2),r)+R[F(2,2)],a=-.5*(a/o+l/c),R[F(1,0)]+=R[F(2,0)]*a,R[F(1,1)]+=R[F(2,1)]*a,R[F(1,2)]+=R[F(2,2)]*a,a=ne(fe(R,1),t)+R[F(1,2)],o=ne(fe(R,2),t)+R[F(2,2)],l=-o/a,R[F(1,0)]*=l,R[F(1,1)]*=l,R[F(1,2)]*=l,s[0]=R[0],s[1]=R[1],s[2]=0,s[3]=R[2],s[4]=R[3],s[5]=R[4],s[6]=0,s[7]=R[5],s[8]=0,s[9]=0,s[10]=1,s[11]=0,s[12]=R[6],s[13]=R[7],s[14]=0,s[15]=R[8]}function Kc(e,t,r,i,s){const a=1/Ce[0][3],o=1/Ce[4][3];pe(a<o);let l=a+Math.sqrt(a*o);const c=Math.sin(_o(e[2]*t[0]+e[6]*t[1]+e[10]*t[2]));l/=c,Yc(Ce,l,c,Ns,js,Jc,zs,Vs),Xc(Ns,js,zs,Vs,s.projectionMatrix),s.projectionMatrix[10]=2/(r-i),s.projectionMatrix[14]=-(r+i)/(r-i)}let ed=class{constructor(){this.adds=new Ae,this.removes=new Ae,this.updates=new Ae({allocator:t=>t||new td,deallocator:t=>(t.renderGeometry=null,t)})}clear(){this.adds.clear(),this.removes.clear(),this.updates.clear()}prune(){this.adds.prune(),this.removes.prune(),this.updates.prune()}get empty(){return this.adds.length===0&&this.removes.length===0&&this.updates.length===0}},td=class{},rd=class{constructor(){this.adds=new Array,this.removes=new Array,this.updates=new Array}};var Fr,Pe;(function(e){e[e.ADD=0]="ADD",e[e.UPDATE=1]="UPDATE",e[e.REMOVE=2]="REMOVE"})(Fr||(Fr={})),function(e){e[e.NONE=0]="NONE",e[e.VISIBILITY=1]="VISIBILITY",e[e.GEOMETRY=2]="GEOMETRY",e[e.TRANSFORMATION=4]="TRANSFORMATION",e[e.HIGHLIGHT=8]="HIGHLIGHT",e[e.OCCLUDEE=16]="OCCLUDEE"}(Pe||(Pe={}));var Ws;function id(e){const t=new Map,r=i=>{let s=t.get(i);return s||(s=new rd,t.set(i,s)),s};return e.removes.forAll(i=>{di(i)&&r(i.material).removes.push(i)}),e.adds.forAll(i=>{di(i)&&r(i.material).adds.push(i)}),e.updates.forAll(i=>{di(i.renderGeometry)&&r(i.renderGeometry.material).updates.push(i)}),t}function di(e){return e.geometry.indexCount>=1}(function(e){e[e.Default=0]="Default",e[e.Screenshot=1]="Screenshot",e[e.ObjectAndLayerID=2]="ObjectAndLayerID"})(Ws||(Ws={}));let sd=class{constructor(t,r){this._material=t,this._repository=r,this._map=new Map}dispose(){this._map.forEach((t,r)=>{t!=null&&this._repository.release(this._material,r)})}load(t,r,i){const s=this._material.produces.get(r);if(!s||!s(i))return null;this._map.has(i)||this._map.set(i,this._repository.acquire(this._material,r,i));const a=this._map.get(i);if(a!=null){if(a.ensureResources(t)===Pn.LOADED)return a;this._repository.requestRender()}return null}},ad=class extends tn{constructor(t=E()){super(),this.origin=t,this.slicePlaneLocalOrigin=this.origin}},Ui=class{constructor(t=0,r=0){this.from=t,this.to=r}get numElements(){return this.to-this.from}};function Bs(e){const t=new Map;e.forAll(i=>t.set(i.from,i));let r=!0;for(;r;){r=!1;for(let i=0;i<e.length;++i){const s=e.data[i],a=t.get(s.to);if(!a)return;s.to=a.to,t.delete(a.from),e.removeUnordered(a),r=!0}}}let ks=class extends Ui{constructor(t,r,i){super(r,i),this.geometry=t}get isVisible(){return this.geometry.visible}get hasHighlights(){return this.geometry.highlights!=null&&this.isVisible}get hasOccludees(){return this.geometry.occludees!=null}};class od{constructor(){this.first=0,this.count=0}}let nd=class{constructor(){this._numElements=0,this._instances=new Map,this.holes=new Ae({allocator:t=>t||new Ui,deallocator:null}),this.hasHiddenInstances=!1,this.hasHighlights=!1,this.hasOccludees=!1,this.drawCommandsDirty=!0,this.drawCommandsDefault=mr(),this.drawCommandsHighlight=mr(),this.drawCommandsOccludees=mr(),this.drawCommandsShadowHighlightRest=mr()}get numElements(){return this._numElements}get instances(){return this._instances}addInstance(t,r){this.deleteInstance(t),this._instances.set(t,r),this._numElements+=r.numElements}deleteInstance(t){const r=this._instances.get(t);r&&(this._numElements-=r.numElements,this._instances.delete(t))}updateInstance(t,r,i){const s=this._instances.get(t);s&&(this._numElements-=s.numElements,s.from=r,s.to=i,this._numElements+=s.numElements)}updateDrawState(t){t.isVisible?(t.hasHighlights&&(this.hasHighlights=!0),t.hasOccludees&&(this.hasOccludees=!0)):this.hasHiddenInstances=!0}updateDrawCommands(t){if(this.drawCommandsDefault.clear(),this.drawCommandsHighlight.clear(),this.drawCommandsOccludees.clear(),this.drawCommandsShadowHighlightRest.clear(),this.drawCommandsDirty=!1,this._instances.size===0)return;if(!this.needsMultipleCommands()){const i=this.drawCommandsDefault.pushNew(),s=this.holes.front();return this.vao!=null&&this.holes.length===1&&s.to===Math.floor(this.vao.byteSize/t)?(i.first=0,void(i.count=s.from)):(i.first=1/0,i.count=0,this._instances.forEach(a=>{i.first=Math.min(i.first,a.from),i.count=Math.max(i.count,a.to)}),void(i.count-=i.first))}const r=Array.from(this._instances.values()).sort((i,s)=>i.from===s.from?i.to-s.to:i.from-s.from);for(const i of r)i.isVisible&&(qs(i.hasOccludees?this.drawCommandsOccludees:this.drawCommandsDefault,i),qs(i.hasHighlights?this.drawCommandsHighlight:this.drawCommandsShadowHighlightRest,i))}needsMultipleCommands(){return this.hasOccludees||this.hasHighlights||this.hasHiddenInstances}};function ld(e){return e.vao!=null}function mr(){return new Ae({allocator:e=>e||new od,deallocator:e=>e})}function qs(e,t){const r=e.back();if(r==null){const i=e.pushNew();return i.first=t.from,void(i.count=t.numElements)}if(cd(r,t)){const i=t.from-r.first+t.numElements;r.count=i}else{const i=e.pushNew();i.first=t.from,i.count=t.numElements}}function cd(e,t){return e.first+e.count>=t.from}let dd=class{constructor(t){this.origin=t,this.buffers=new Array}dispose(){this.buffers.forEach(t=>t.vao.dispose()),this.buffers.length=0}findBuffer(t){return this.buffers.find(r=>r.instances.has(t))}};class hd{constructor(t,r){this._cache=t(r,(i,s,a)=>this._remove(i,s,a))}hitrate(){return this._cache.hitRate}destroy(){this._cache.destroy()}clear(){this._cache.clear()}getSize(t){return this._cache.getSize(t)}pop(t){const r=this._cache.peek(t);if(!r)return;const i=r.pop();if(r.length>0){if(i){const s=this._cache.getSize(t)-Math.round(i.usedMemory);this._cache.updateSize(t,r,s)}}else this._cache.pop(t);return i}put(t,r,i=vo){const s=this._cache.peek(t);if(!s)return void this._cache.put(t,[r],r.usedMemory,i);s.push(r);const a=this._cache.getSize(t)+Math.round(r.usedMemory);this._cache.updateSize(t,s,a)}_remove(t,r,i){switch(r){case Yi.ALL:return t.forEach(s=>s.dispose()),0;case Yi.SOME:{const s=t.shift();return s&&(i-=Math.round(s.usedMemory),s.dispose()),i}}}}class ud{constructor(t,r,i){this._rctx=t,this._locations=r,this._layout=i,this._cache=new hd(t.newCache,"VAOCache")}dispose(){this._cache.destroy()}newVao(t){const r=t.toString();let i=this._cache.pop(r);return i||(i=new il(this._rctx,this._locations,{geometry:this._layout},{geometry:Kn.createVertex(this._rctx,qn.STATIC_DRAW)}),i.vertexBuffers.geometry.setSize(t),i)}deleteVao(t){if(t==null)return;const r=t.byteSize.toString();this._cache.put(r,t)}}let Or=class extends rn{constructor(e){super(e),this._vaoCache=null,this._glMaterials=null,this._bufferWriter=null,this._dataByOrigin=new Map,this._hasHighlights=!1,this._hasOccludees=!1,this._produces=new Map,this.drapedPriority=0}destroy(){this._glMaterials=Yt(this._glMaterials),this._dataByOrigin.forEach(e=>e.dispose()),this._dataByOrigin.clear(),this._vaoCache=Yt(this._vaoCache)}initialize(){this.material.produces.forEach((e,t)=>{this._produces.set(t,r=>!(this._dataByOrigin.size===0||!(r!==M.Highlight&&r!==M.ShadowHighlight||this._hasHighlights))&&e(r))})}get produces(){return this._produces}initializeRenderContext(e,t){const{rctx:r}=e.renderContext;this._glMaterials=new sd(this.material,t??e.materialRepository),this._bufferWriter=this.material.createBufferWriter(),this._vaoCache=new ud(r,this.material.vertexAttributeLocations,Yn(this._bufferWriter.vertexBufferLayout))}uninitializeRenderContext(){}get hasOccludees(){return this._hasOccludees}get isDecoration(){return this.material.parameters.isDecoration}queryRenderOccludedState(e){return this.material.queryRenderOccludedState(e)}get materialReference(){return this.material}get numGeometries(){let e=0;return this._dataByOrigin.forEach(t=>e+=t.buffers.reduce((r,i)=>r+i.instances.size,0)),e}get usedMemory(){let e=0;return this._dataByOrigin.forEach(t=>e+=t.buffers.reduce((r,i)=>r+i.vao.usedMemory,0)),e}forEachGeometry(e){this._dataByOrigin.forEach(t=>t.buffers.forEach(r=>r.instances.forEach(i=>e(i.geometry))))}modify(e){this._updateGeometries(e.updates),this._addAndRemoveGeometries(e.adds,e.removes),this._updateDrawCommands()}_updateGeometries(e){const t=this._bufferWriter;if(t===null)return;const r=t.vertexBufferLayout.stride/4;for(const i of e){const s=i.renderGeometry,a=this._dataByOrigin.get(s.localOrigin.id),o=a==null?void 0:a.findBuffer(s.id);if(o==null)return;const l=o.instances.get(s.id);if(i.updateType&(Pe.GEOMETRY|Pe.TRANSFORMATION)){const c=vr(t.elementCount(l.geometry.geometry)*r),n=t.vertexBufferLayout.createView(c.buffer);this._writeGeometry(s,n,0),o.vao.vertexBuffers.geometry.setSubData(c,l.from*r,0,l.numElements*r)}i.updateType&(Pe.HIGHLIGHT|Pe.OCCLUDEE|Pe.VISIBILITY)&&(o.drawCommandsDirty=!0)}}_computeDeltas(e,t){const r=new Fi;for(const i of e){const s=i.localOrigin;if(s==null)continue;let a=r.get(s.id,null);a==null&&(a=new Zs(s.vec3),r.set(s.id,null,a)),a.changes.push(i)}for(const i of t){const s=i.localOrigin;if(s==null)continue;const a=this._dataByOrigin.get(s.id),o=a==null?void 0:a.findBuffer(i.id);if(o==null)continue;let l=r.get(s.id,o);l==null&&(l=new Zs(s.vec3),r.set(s.id,o,l)),l.changes.push(i)}return r}_addAndRemoveGeometries(e,t){if(this._bufferWriter===null||this._vaoCache===null)return;const{_bufferWriter:r,_dataByOrigin:i}=this,s=r.vertexBufferLayout.stride/4,a=this._computeDeltas(e,t);a.forEach((o,l)=>{const c=o.get(null),n=c!=null?c.changes:[];a.delete(l,null);let d=i.get(l);if(o.forEach((h,p)=>{if(a.delete(l,p),p==null)return void pe(!1,"No VAO for removed geometries");if(p.instances.size===h.changes.length)return this._vaoCache.deleteVao(p.vao),Xi(d.buffers,p),void(d.buffers.length===0&&n.length===0&&i.delete(l));const u=p.numElements,f=p.vao.byteSize/4,_=n.reduce((v,O)=>v+r.elementCount(O.geometry),0),x=h.changes.reduce((v,O)=>v+r.elementCount(O.geometry),0),T=Math.min((u+_-x)*s,_r),S=T>f;T>Nr&&T<f/2?(h.changes.forEach(({id:v})=>p.deleteInstance(v)),p.instances.forEach(({geometry:v})=>n.push(v)),this._vaoCache.deleteVao(p.vao),Xi(d.buffers,p)):S?this._applyAndRebuild(p,n,h):this._applyRemoves(p,h)}),n.length>0)for(d==null&&(d=new dd(c.origin),i.set(l,d)),d.buffers.forEach(h=>this._applyAdds(h,n));n.length>0;)d.buffers.push(this._applyAndRebuild(new nd,n,null))})}_updateDrawCommands(){this._hasHighlights=!1,this._hasOccludees=!1,this._dataByOrigin.forEach(e=>{e.buffers.forEach(t=>{t.drawCommandsDirty&&(t.hasHiddenInstances=!1,t.hasHighlights=!1,t.hasOccludees=!1,Wt(t.instances,r=>(t.updateDrawState(r),t.hasHiddenInstances&&t.hasHighlights&&t.hasOccludees)),t.updateDrawCommands(this._bufferWriter.vertexBufferLayout.stride)),this._hasHighlights=this._hasHighlights||t.hasHighlights,this._hasOccludees=this._hasOccludees||t.hasOccludees})})}_applyAndRebuild(e,t,r){if(r!=null)for(const u of r.changes)e.deleteInstance(u.id);const i=this._bufferWriter,s=i.vertexBufferLayout.stride,a=s/4,o=Math.floor(_r/a);let l=e.numElements;for(;t.length>0;){const u=t.pop(),f=i.elementCount(u.geometry);if(l+f>o&&l>0){t.push(u);break}l+=f;const _=new ks(u,0,0);pe(e.instances.get(u.id)==null),e.addInstance(u.id,_)}const c=l*a,n=vr(c),d=i.vertexBufferLayout.createView(n.buffer);let h=0;e.hasHiddenInstances=!1,e.hasHighlights=!1,e.hasOccludees=!1,e.instances.forEach((u,f)=>{this._writeGeometry(u.geometry,d,h);const _=h;h+=i.elementCount(u.geometry.geometry),e.updateInstance(f,_,h),e.updateDrawState(u)}),this._vaoCache.deleteVao(e.vao),e.vao=this._vaoCache.newVao(Ys(c)),e.vao.vertexBuffers.geometry.setSubData(n,0,0,h*a),e.holes.clear();const p=e.holes.pushNew();return p.from=h,p.to=Math.floor(e.vao.byteSize/s),e.updateDrawCommands(s),e}_applyRemoves(e,t){if(t.changes.length===0||this._bufferWriter===null)return;for(const o of t.changes){const l=o.id,c=e.instances.get(l);if(!c)continue;e.deleteInstance(l);const n=$e.back();if(n){if(n.to===c.from){n.to=c.to;continue}if(n.from===c.to){n.from=c.from;continue}}const d=$e.pushNew();d.from=c.from,d.to=c.to}Bs($e);const r=this._bufferWriter.vertexBufferLayout.stride/4,i=$e.reduce((o,l)=>Math.max(o,l.numElements),0)*r,s=vr(i);s.fill(0,0,i);const a=e.vao.vertexBuffers.geometry;$e.forAll(o=>a.setSubData(s,o.from*r,0,o.numElements*r)),e.holes.pushArray($e.data,$e.length),$e.forAll((o,l)=>$e.data[l]=null),$e.clear(),e.drawCommandsDirty=!0}_applyAdds(e,t){if(t.length===0||this._bufferWriter===null)return;if(!ld(e))return void this._applyAndRebuild(e,t,null);const r=this._bufferWriter,i=r.vertexBufferLayout.stride/4,s=e.numElements,a=t.reduce((x,T)=>x+r.elementCount(T.geometry),0),o=Math.min((s+a)*i,_r),l=4*o;if(e.vao.byteSize<Ys(_r-Nr)&&l>e.vao.byteSize)return void this._applyAndRebuild(e,t,null);Bs(e.holes);const c=new Array;for(const x of t){const T=r.elementCount(x.geometry),S=pd(e.holes,T);c.push(S)}const n=e.vao.vertexBuffers.geometry;let d=0,h=0,p=0;const u=vr(o),f=r.vertexBufferLayout.createView(u.buffer);t.forEach((x,T)=>{const S=c[T];if(S==null)return;if(p!==S){const C=p-h;C>0&&n.setSubData(u,h*i,0,C*i),h=S,d=0}const v=r.elementCount(x.geometry);this._writeGeometry(x,f,d),d+=v,p=S+v;const O=new ks(x,S,S+v);pe(e.instances.get(x.id)==null),e.addInstance(x.id,O),e.drawCommandsDirty=!0});const _=p-h;_>0&&n.setSubData(u,h*i,0,_*i),yo(t,(x,T)=>c[T]==null)}_writeGeometry(e,t,r){if(this._bufferWriter===null)return;const i=e.localOrigin.vec3;gn(Qs,-i[0],-i[1],-i[2]);const s=Be(fd,Qs,e.transformation);kt(gr,s),ea(gr,gr),this._bufferWriter.write(s,gr,e.geometry,t,r)}updateAnimation(e){return this.material.update(e)}prepareTechnique(e){if(!this.material.shouldRender(e))return null;const{output:t,bindParameters:r}=e,i=this.material.produces.get(r.slot);if(!i||!i(t))return null;const s=t===M.Highlight||t===M.ShadowHighlight;if(s&&!this._hasHighlights)return null;const a=t===M.ShadowExcludeHighlight,o=!(s||a);for(const l of this._dataByOrigin.values())for(const c of l.buffers){if(s&&!c.hasHighlights)continue;const n=(s?c.drawCommandsHighlight:a&&c.needsMultipleCommands()?c.drawCommandsShadowHighlightRest:c.drawCommandsDefault)||null,d=o&&c.drawCommandsOccludees||null;if(n!=null&&n.length||d!=null&&d.length){const h=this._glMaterials.load(e.rctx,r.slot,t),p=h!=null?h.beginSlot(r):null;if(p!=null)return p}}return null}renderNode(e,t){const{output:r,bindParameters:i}=e,s=r===M.Highlight||r===M.ShadowHighlight,a=r===M.ShadowExcludeHighlight,o=!(s||a),l=e.rctx,c=e.bindParameters.slot===ie.OCCLUDER_MATERIAL,n=e.bindParameters.slot===ie.TRANSPARENT_OCCLUDER_MATERIAL;l.runAppleAmdDriverHelper(),l.bindTechnique(t,i,this.material.parameters);for(const d of this._dataByOrigin.values())for(const h of d.buffers){if(s&&!h.hasHighlights)continue;const p=(s?h.drawCommandsHighlight:a&&h.needsMultipleCommands()?h.drawCommandsShadowHighlightRest:h.drawCommandsDefault)||null,u=o&&h.drawCommandsOccludees||null;(p!=null&&p.length||u!=null&&u.length)&&(t.program.bindDraw(new ad(d.origin),i,this.material.parameters),t.ensureAttributeLocations(h.vao),l.bindVAO(h.vao),p!=null&&p.length&&(l.setPipelineState(t.getPipeline(!1,c,n)),p.forAll(f=>l.drawArrays(t.primitiveType,f.first,f.count))),u!=null&&u.length&&(l.setPipelineState(t.getPipeline(!0,c,n)),u.forAll(f=>l.drawArrays(t.primitiveType,f.first,f.count))))}}get test(){return{material:this.material,glMaterials:this._glMaterials,dataByOrigin:this._dataByOrigin}}};m([b({constructOnly:!0})],Or.prototype,"material",void 0),Or=m([tr("esri.views.3d.webgl-engine.materials.renderers.MergedRenderer")],Or);class Zs{constructor(t){this.origin=t,this.changes=new Array}}function pd(e,t){let r;if(!e.some(s=>!(s.numElements<t)&&(r=s,!0)))return null;const i=r.from;return r.from+=t,r.from>=r.to&&e.removeUnordered(r),i}const Qs=W(),fd=W(),gr=W(),$e=new Ae({allocator:e=>e||new Ui,deallocator:null}),Nr=65536,hi=4*Nr,Js=1024,Ba=16777216,_r=Ba/4;let ui=new Float32Array(Nr);function vr(e){return ui.length<e&&(ui=new Float32Array(e)),ui}function Ys(e){const t=4*e;return t<=Js?Js:t<hi?wo(t):Math.max(Math.min(Math.ceil(1.5*t/hi)*hi,Ba),t)}let xe=class extends Ks{constructor(e){super(e),this._pending=new md,this._changes=new ed,this._materialRenderers=new Ae,this._sortedMaterialRenderers=new Ae,this._geometries=new Map,this._hasHighlights=!1,this._hasWater=!1}destroy(){this._changes.prune(),this._materialRenderers.forAll(e=>e.destroy()),this._materialRenderers.clear(),this._sortedMaterialRenderers.clear(),this._geometries.clear(),this._pending.clear()}get updating(){return!this._pending.empty||this._changes.updates.length>0}get rctx(){return this.rendererContext.rctx}get _materialRepository(){return this.rendererContext.materialRepository}get _localOriginFactory(){return this.rendererContext.localOriginFactory}get hasHighlights(){return this._hasHighlights}get hasWater(){return this._hasWater}get rendersOccludedDraped(){return this._materialRenderers.some(e=>e.numGeometries!==0&&!e.queryRenderOccludedState(Oe.Occlude))}get isEmpty(){return!this.updating&&this._materialRenderers.length===0&&this._geometries.size===0}getMemoryForMaterial(e){if(e==null)return 0;const t=this._materialRenderers.find(r=>r.materialReference===e);return(t==null?void 0:t.usedMemory)??0}commitChanges(){if(!this.updating)return!1;this._processAddsRemoves();const e=id(this._changes);let t=!1;return e.forEach((r,i)=>{let s=this._materialRenderers.find(a=>a.materialReference===i);if(!s&&r.adds.length>0){const a=new Or({material:i});a.initializeRenderContext(this.rendererContext.pluginContext,this._materialRepository),s=a,this._materialRenderers.push(s),t=!0}s&&(s.modify(r),s.numGeometries===0&&(this._materialRenderers.removeUnordered(s),s.destroy(),t=!0))}),this._changes.clear(),t&&this._updateSortedMaterialRenderers(),this._hasHighlights=this._materialRenderers.some(r=>{const i=r.produces.get(ie.DRAPED_MATERIAL);return!!i&&i(M.Highlight)}),this._hasWater=this._materialRenderers.some(r=>{const i=r.produces.get(ie.DRAPED_WATER);return!!i&&i(M.Normal)}),this.notifyChange("updating"),!0}addGeometries(e,t){if(e.length===0)return;const r=this._validateRenderGeometries(e);for(const s of r)this._geometries.set(s.id,s);const i=this._pending.empty;for(const s of r)this._pending.adds.add(s);i&&this.notifyChange("updating"),t===Fr.UPDATE&&this._notifyGraphicGeometryChanged(e)}removeGeometries(e,t){const r=this._pending.empty,i=this._pending.adds;for(const s of e)i.has(s)?(this._pending.removed.add(s),i.delete(s)):this._pending.removed.has(s)||this._pending.removes.add(s),this._geometries.delete(s.id);r&&!this._pending.empty&&this.notifyChange("updating"),t===Fr.UPDATE&&this._notifyGraphicGeometryChanged(e)}modifyGeometries(e,t){const r=this._changes.updates.length===0;for(const i of e){const s=this._changes.updates.pushNew();s.renderGeometry=this._validateRenderGeometry(i),s.updateType=t}switch(r&&this._changes.updates.length>0&&this.notifyChange("updating"),t){case Pe.TRANSFORMATION:case Pe.GEOMETRY:return this._notifyGraphicGeometryChanged(e);case Pe.VISIBILITY:return this._notifyGraphicVisibilityChanged(e)}}updateAnimation(e){let t=!1;return this._sortedMaterialRenderers.forAll(r=>t=!!r.updateAnimation&&r.updateAnimation(e)||t),t}shouldRender(e){return this._sortedMaterialRenderers.some(t=>t.prepareTechnique(e))}render(e){this._sortedMaterialRenderers.forAll(t=>{const r=t.prepareTechnique(e);r!=null&&t.renderNode(e,r)})}intersect(e,t,r,i,s){return this._geometries.forEach(a=>{if(i&&!i(a))return;this._intersectRenderGeometry(a,r,t,0,e,s);const o=this.rendererContext.longitudeCyclical;o&&(a.boundingSphere[0]-a.boundingSphere[3]<o.min&&this._intersectRenderGeometry(a,r,t,o.range,e,s),a.boundingSphere[0]+a.boundingSphere[3]>o.max&&this._intersectRenderGeometry(a,r,t,-o.range,e,s)),s++}),s}_updateSortedMaterialRenderers(){this._sortedMaterialRenderers.clear(),this._materialRenderers.forAll((e,t)=>{e.drapedPriority=t,this._sortedMaterialRenderers.push(e)}),this._sortedMaterialRenderers.sort((e,t)=>{var r,i,s,a;return((r=t.materialReference)==null?void 0:r.renderPriority)===((i=e.materialReference)==null?void 0:i.renderPriority)?e.drapedPriority-t.drapedPriority:(((s=t.materialReference)==null?void 0:s.renderPriority)||0)-(((a=e.materialReference)==null?void 0:a.renderPriority)||0)})}_processAddsRemoves(){this._changes.adds.clear(),this._changes.removes.clear(),this._changes.adds.pushArray(Array.from(this._pending.adds)),this._changes.removes.pushArray(Array.from(this._pending.removes));for(let e=0;e<this._changes.updates.length;){const t=this._changes.updates.data[e];this._pending.has(t.renderGeometry)?this._changes.updates.removeUnorderedIndex(e):e++}this._pending.clear()}_intersectRenderGeometry(e,t,r,i,s,a){if(!e.visible)return;let o=0;i+=e.transformation[12],o=e.transformation[13],pi[0]=r[0]-i,pi[1]=r[1]-o,e.screenToWorldRatio=this.rendererContext.screenToWorldRatio,e.material.intersectDraped(e,null,s,pi,(l,c,n)=>{gd(t,n,a,e.material.renderPriority,s,e.layerUid,e.graphicUid)},t)}_notifyGraphicGeometryChanged(e){if(this.drapeSource.notifyGraphicGeometryChanged==null)return;let t;for(const r of e){const i=r.graphicUid;i!=null&&i!==t&&(this.drapeSource.notifyGraphicGeometryChanged(i),t=i)}}_notifyGraphicVisibilityChanged(e){if(this.drapeSource.notifyGraphicVisibilityChanged==null)return;let t;for(const r of e){const i=r.graphicUid;i!=null&&i!==t&&(this.drapeSource.notifyGraphicVisibilityChanged(i),t=i)}}_validateRenderGeometries(e){for(const t of e)this._validateRenderGeometry(t);return e}_validateRenderGeometry(e){return e.localOrigin==null&&(e.localOrigin=this._localOriginFactory.getOrigin(Mr(e.boundingSphere))),e}get test(){return{sortedMaterialRenderers:this._sortedMaterialRenderers}}};m([b()],xe.prototype,"drapeSource",void 0),m([b()],xe.prototype,"updating",null),m([b()],xe.prototype,"rctx",null),m([b({constructOnly:!0})],xe.prototype,"rendererContext",void 0),m([b()],xe.prototype,"_materialRepository",null),m([b()],xe.prototype,"_localOriginFactory",null),m([b({readOnly:!0})],xe.prototype,"isEmpty",null),m([b()],xe.prototype,"_materialRenderers",void 0),m([b()],xe.prototype,"_geometries",void 0),xe=m([tr("esri.views.3d.webgl-engine.lib.SortedRenderGeometryRenderer")],xe);class md{constructor(){this.adds=new Set,this.removes=new Set,this.removed=new Set}get empty(){return this.adds.size===0&&this.removes.size===0&&this.removed.size===0}has(t){return this.adds.has(t)||this.removes.has(t)||this.removed.has(t)}clear(){this.adds.clear(),this.removes.clear(),this.removed.clear()}}function gd(e,t,r,i,s,a,o){const l=new Jn(a,o,t),c=n=>{n.set(Cn.OVERLAY,l,e.dist,e.normal,e.transformation,r,i)};if((s.results.min.drapedLayerOrder==null||r>=s.results.min.drapedLayerOrder)&&(s.results.min.dist==null||s.results.ground.dist<=s.results.min.dist)&&c(s.results.min),s.options.store!==hs.MIN&&(s.results.max.drapedLayerOrder==null||r<s.results.max.drapedLayerOrder)&&(s.results.max.dist==null||s.results.ground.dist>s.results.max.dist)&&c(s.results.max),s.options.store===hs.ALL){const n=xn(s.ray);c(n),s.results.all.push(n)}}const pi=k();let ka=class qa extends Ii{initializeProgram(t){return new Pi(t.rctx,qa.shader.get().build(),ua)}initializePipeline(){return this.configuration.hasAlpha?tt({blending:Wn(Ot.SRC_ALPHA,Ot.ONE,Ot.ONE_MINUS_SRC_ALPHA,Ot.ONE_MINUS_SRC_ALPHA),colorWrite:Et}):tt({colorWrite:Et})}};ka.shader=new $i(oc,()=>bi(()=>import("./ColorMaterial.glsl-uPKQoFFi.js").then(e=>e.T),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30])));class Za extends ma{constructor(){super(...arguments),this.hasAlpha=!1}}m([P()],Za.prototype,"hasAlpha",void 0);class Qa extends pa{constructor(){super(...arguments),this.overlayIndex=be.INNER,this.opacity=1}}function _d(){const e=new Mi;return e.include(na),e.fragment.uniforms.add(new ke("tex",t=>t.texture)),e.fragment.uniforms.add(new sn("overlayIdx",t=>t.overlayIndex)),e.fragment.uniforms.add(new Z("opacity",t=>t.opacity)),e.fragment.code.add(w`void main() {
vec2 overlayUV = overlayIdx == 0 ? vec2(uv.x * 0.5, uv.y) : vec2(uv.x * 0.5 + 0.5, uv.y);
fragColor = texture(tex, overlayUV) * opacity;
}`),e}const vd=Object.freeze(Object.defineProperty({__proto__:null,OverlayCompositingPassParameters:Qa,build:_d},Symbol.toStringTag,{value:"Module"}));class Vr extends Ii{initializeProgram(t){return new Pi(t.rctx,Vr.shader.get().build(),ua)}initializePipeline(){return tt({blending:Bn(Ot.ONE,Ot.ONE_MINUS_SRC_ALPHA),colorWrite:Et})}}Vr.shader=new $i(vd,()=>bi(()=>import("./ColorMaterial.glsl-uPKQoFFi.js").then(e=>e.O),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30])));let Te=class extends an{constructor(e){super(e),this._overlays=null,this._renderTargets=null,this._overlayParameters=new Qa,this.hasHighlights=!1,this._hasWater=!1,this._renderers=new Map,this._sortedDrapeSourceRenderersDirty=!1,this._sortedRenderers=new Ae,this._passParameters=new ba,this._materialRepository=null,this._screenToWorldRatio=1,this._localOriginFactory=null,this.unloadedMemory=0,this.ignoresMemoryFactor=!1,this._camera=new I,this.worldToPCSRatio=1,this.events=new ra,this.longitudeCyclical=null,this.produces=new Map([[ie.DRAPED_MATERIAL,t=>t!==M.Highlight||this.hasHighlights],[ie.DRAPED_WATER,()=>this._hasWater]]),this._hasTargetWithoutRasterImage=!1,this._hasDrapedFeatureSource=!1,this._hasDrapedRasterSource=!1}initialize(){const e=this.view._stage.renderer.fboCache,t=this.view._stage.renderView,{waterTextures:r,stippleTextures:i,markerTextures:s}=t;this._shaderTechniques=new nc({rctx:this._rctx,viewingMode:Li.Local,stippleTextureRepository:i,markerTextureRepository:s,waterTextureRepository:r}),this._renderContext=new Wa(this._rctx,new Zc(e,this.view.state.viewingMode),null),this.addHandles([Hr(()=>r.updating,()=>this.events.emit("content-changed"),Ki),Hr(()=>this.spatialReference,a=>this._localOriginFactory=new kc(a),Ki),xo(()=>this.view.allLayerViews,"after-changes",()=>this._sortedDrapeSourceRenderersDirty=!0)]),this._materialRepository=new dc(t.textureRepository,this._shaderTechniques,()=>{this.notifyChange("rendersOccludedDraped"),this.events.emit("content-changed"),this.notifyChange("updating"),this.notifyChange("isEmpty")},()=>this.events.emit("content-changed")),this._bindParameters.slot=ie.DRAPED_MATERIAL,this._bindParameters.mainDepth=null,this._camera.near=1,this._camera.far=1e4,this._camera.relativeElevation=null,this._bindParameters.camera=this._camera,this._bindParameters.transparencyPassType=Ue.NONE,this._bindParameters.newLighting.noonFactor=0,this._bindParameters.newLighting.globalFactor=0,this._bindParameters.newLighting.set([new on(st(1,1,1))]),this.addHandles(this.view.resourceController.scheduler.registerTask(el.STAGE,this))}destroy(){this._renderers.forEach(e=>e.destroy()),this._renderers.clear(),this._debugTextureTechnique=br(this._debugTextureTechnique),this._passParameters.texture=Yt(this._passParameters.texture),this._shaderTechniques=ia(this._shaderTechniques),this.disposeOverlays()}get _bindParameters(){return this._renderContext.bindParameters}get _rctx(){return this.view._stage.renderView.renderingContext}get rctx(){return this._rctx}get materialRepository(){return this._materialRepository}get screenToWorldRatio(){return this._screenToWorldRatio}get localOriginFactory(){return this._localOriginFactory}initializeRenderContext(e){this.pluginContext=e}uninitializeRenderContext(){}renderNode(){}get updating(){return this._sortedDrapeSourceRenderersDirty||Wt(this._renderers,e=>e.updating)}get hasOverlays(){return this._overlays!=null&&this._renderTargets!=null}getMemoryForMaterial(e){return Array.from(this._renderers.values()).reduce((t,r)=>t+r.getMemoryForMaterial(e),0)}get layers(){return this._sortedDrapeSourceRenderersDirty&&this._updateSortedDrapeSourceRenderers(),this._sortedRenderers.map(e=>e.drapeSource.layer).filter(e=>!!e)}createGeometryDrapeSourceRenderer(e){return this.createDrapeSourceRenderer(e,xe)}createDrapeSourceRenderer(e,t,r){const i=this._renderers.get(e);i!=null&&i.destroy();const s=new t({...r,rendererContext:this,drapeSource:e});return this._renderers.set(e,s),this._sortedDrapeSourceRenderersDirty=!0,"fullOpacity"in e&&this.addHandles(Hr(()=>e.fullOpacity,()=>this.events.emit("content-changed")),e),s}removeDrapeSourceRenderer(e){if(e==null)return;const t=this._renderers.get(e);t!=null&&(this._sortedDrapeSourceRenderersDirty=!0,this._renderers.delete(e),this.removeHandles(e),t.destroy())}computeValidity(){var e;return((e=this._renderTargets)==null?void 0:e.computeValidity())??0}releaseRenderTargets(){var e;(e=this._renderTargets)==null||e.dispose()}get overlays(){return this._overlays??[]}ensureDrapeTargets(e){this._hasTargetWithoutRasterImage=!!this._overlays&&Gr(e,t=>t.drapeTargetType===Ci.WithoutRasterImage)}ensureDrapeSources(e){this._overlays?(this._hasDrapedFeatureSource=Gr(e,t=>t.drapeSourceType===Zt.Features),this._hasDrapedRasterSource=Gr(e,t=>t.drapeSourceType===Zt.RasterImage)):this._hasDrapedFeatureSource=this._hasDrapedRasterSource=!1}get _needsColorWithoutRasterImage(){return this._hasDrapedRasterSource&&this._hasDrapedFeatureSource&&this._hasTargetWithoutRasterImage}ensureOverlays(e,t,r=this._bindParameters.overlayStretch){this._overlays==null&&(this._renderTargets=new Xl(this.view._stage.renderer.fboCache),this._overlays=[new bs,new bs]),this.ensureDrapeTargets(e),this.ensureDrapeSources(t),this._bindParameters.overlayStretch=r}disposeOverlays(){this._overlays=null,this._renderTargets=Yt(this._renderTargets),this.events.emit("textures-disposed")}getTexture(e){var t,r;if(e!=null)return e===Y.ColorNoRasterImage&&!this._needsColorWithoutRasterImage&&this._hasDrapedFeatureSource?(t=this._renderTargets)==null?void 0:t.getTexture(Y.Color):(r=this._renderTargets)==null?void 0:r.getTexture(e)}get running(){return this.updating}runTask(e){this._processDrapeSources(e,()=>!0)}_processDrapeSources(e,t){let r=!1;for(const[i,s]of this._renderers){if(e.done)break;(i.destroyed||t(i))&&s.commitChanges()&&(r=!0,e.madeProgress())}this._sortedDrapeSourceRenderersDirty&&(this._sortedDrapeSourceRenderersDirty=!1,r=!0,this._updateSortedDrapeSourceRenderers()),r&&(this._overlays!=null&&this._renderers.size===0&&this.disposeOverlays(),this.notifyChange("updating"),this.notifyChange("isEmpty"),this.events.emit("content-changed"),this.hasHighlights=Wt(this._renderers,i=>i.hasHighlights),this.notifyChange("rendersOccludedDraped"),this._updateHasWater())}processSyncDrapeSources(){this._processDrapeSources(tl,e=>e.updatePolicy===Kt.SYNC)}get isEmpty(){return!qr.OVERLAY_DRAW_DEBUG_TEXTURE&&!Wt(this._renderers,e=>!e.isEmpty)}get hasWater(){return this._hasWater}get rendersOccludedDraped(){const e=this._renderContext.renderOccludedMask;this._renderContext.renderOccludedMask=Xs;const t=this._sortedRenderers.some(({renderer:r})=>r.shouldRender(this._renderContext));return this._renderContext.renderOccludedMask=e,t}renders(e){return qr.OVERLAY_DRAW_DEBUG_TEXTURE&&e!==Y.Occluded||this._sortedRenderers.some(({renderer:t})=>t.shouldRender(this._renderContext))}get mode(){var e,t;return this.isEmpty?At.Disabled:(e=this._renderTargets)!=null&&e.getTexture(Y.WaterNormal)?At.EnabledWithWater:(t=this._renderTargets)!=null&&t.getTexture(Y.Color)?At.Enabled:At.Disabled}updateAnimation(e){let t=!1;return this._renderers.forEach(r=>t=r.updateAnimation(e)||t),t}updateDrapeSourceOrder(){this._sortedDrapeSourceRenderersDirty=!0}drawOverlays(e){if(this._overlays&&this._renderTargets){for(const t of this._overlays)this.longitudeCyclical?t.setupGeometryViewsCyclical(this.longitudeCyclical):t.setupGeometryViewsDirect();for(const t of this._renderTargets.targets){if(t.content===Y.ColorNoRasterImage&&!this._needsColorWithoutRasterImage)continue;const r=this._drawTarget(be.INNER,t,e),i=this._drawTarget(be.OUTER,t,e);(r||i)&&t.fbo.generateMipMap()}}}_drawTarget(e,t,r){const i=this._overlays[e],s=i.canvasGeometries;if(s.numViews===0)return!1;const{alignPixelEnabled:a,contentPixelRatio:o}=r;this._screenToWorldRatio=o*i.mapUnitsPerPixel/this._bindParameters.overlayStretch;const l=t.output;if(this.isEmpty||l===M.Highlight&&!this.hasHighlights||l===M.Normal&&!this.hasWater||!i.hasSomeSizedView())return!1;const c=this._rctx;if(this._camera.pixelRatio=i.pixelRatio*o,this._renderContext.output=l,this._bindParameters.alignPixelEnabled=a,this._bindParameters.screenToWorldRatio=this._screenToWorldRatio,this._bindParameters.screenToPCSRatio=this._screenToWorldRatio*this.worldToPCSRatio,this._bindParameters.slot=l===M.Normal?ie.DRAPED_WATER:ie.DRAPED_MATERIAL,t.content===Y.Occluded&&(this._renderContext.renderOccludedMask=Xs),!this.renders(t.content))return this._renderContext.renderOccludedMask=Ti,!1;const n=i.resolution;this._rctx.setViewport(e===be.INNER?0:n,0,n,n);const d=2*i.resolution,h=i.resolution,p=t.fbo;if(p.bind(c,d,h),e===be.INNER&&(c.setClearColor(0,0,0,0),c.clearSafe($r.COLOR_BUFFER_BIT)),qr.OVERLAY_DRAW_DEBUG_TEXTURE&&t.content!==Y.Occluded)for(let u=0;u<s.numViews;u++)this._setViewParameters(s.extents[u],i),this._ensureDebugPatternResources(i.resolution,wd[e]),this._rctx.bindTechnique(this._debugTextureTechnique,this._renderContext.bindParameters,this._passParameters),this._rctx.screen.draw();return this._sortedRenderers.forAll(({drapeSource:u,renderer:f})=>{if(t.content===Y.ColorNoRasterImage&&u.drapeSourceType===Zt.RasterImage)return;const{fullOpacity:_}=u,x=_!=null&&_<1&&l===M.Color?this.bindTemporaryFramebuffer(d,h):null;for(let T=0;T<s.numViews;T++)this._setViewParameters(s.extents[T],i),f.render(this._renderContext);if(x){p.bind(c,d,h),this._overlayParameters.texture=x.getTexture(),this._overlayParameters.opacity=_,this._overlayParameters.overlayIndex=e;const T=this.pluginContext.techniqueRepository.acquire(Vr);this._rctx.bindTechnique(T,this._renderContext.bindParameters,this._overlayParameters),this._rctx.screen.draw(),T.release(),x.release()}}),c.bindFramebuffer(null),this._renderContext.renderOccludedMask=Ti,!0}bindTemporaryFramebuffer(e,t){const r=this.view._stage.renderer.fboCache,i=r.acquire(e,t,"overlay tmp");return r.rctx.unbindTexture(i.fbo.colorTexture),r.rctx.bindFramebuffer(i.fbo),r.rctx.clearSafe($r.COLOR_BUFFER_BIT),i}async reloadShaders(){await this._shaderTechniques.reloadAll()}notifyContentChanged(){this.events.emit("content-changed")}intersect(e,t,r,i){var a;this._sortedDrapeSourceRenderersDirty&&this._updateSortedDrapeSourceRenderers();let s=0;for(const{renderer:o}of this._sortedRenderers)s=((a=o.intersect)==null?void 0:a.call(o,e,t,r,i,s))??s}_updateSortedDrapeSourceRenderers(){if(this._sortedRenderers.clear(),this._renderers.size===0)return;const e=this.view.map.allLayers,t=e.length;this._renderers.forEach((r,i)=>{const s=e.indexOf(i.layer),a=s>=0,o=i.renderGroup??(a?Pr.MapLayer:Pr.ViewLayer),l=t*o+(a?s:0);this._sortedRenderers.push(new yd(i,r,l))}),this._sortedRenderers.sort((r,i)=>r.index-i.index)}_setViewParameters(e,t){const r=this._camera;r.viewport=[0,0,t.resolution,t.resolution],Co(r.projectionMatrix,0,e[2]-e[0],0,e[3]-e[1],r.near,r.far),So(r.viewMatrix,[-e[0],-e[1],0])}_updateHasWater(){const e=Wt(this._renderers,t=>t.hasWater);e!==this._hasWater&&(this._hasWater=e,this.events.emit("has-water",e))}_ensureDebugPatternResources(e,t){if(Q(this._passParameters.color,t[0],t[1],t[2]),this._passParameters.texture)return;const r=new Uint8Array(e*e*4);let i=0;for(let o=0;o<e;o++)for(let l=0;l<e;l++){const c=Math.floor(l/10),n=Math.floor(o/10);c<2||n<2||10*c>e-20||10*n>e-20?(r[i++]=255,r[i++]=255,r[i++]=255,r[i++]=255):(r[i++]=255,r[i++]=255,r[i++]=255,r[i++]=1&c&&1&n?1&l^1&o?0:255:1&c^1&n?0:128)}const s=new ji(e);s.samplingMode=Zn.NEAREST,this._passParameters.texture=new Xt(this._rctx,s,r);const a=new Za;a.hasAlpha=!0,this._debugTextureTechnique=this._shaderTechniques.acquire(ka,a)}get test(){return{drapedRenderers:Array.from(this._renderers.values()),sortedDrapeSources:Array.from(this._sortedRenderers).map(({drapeSource:e})=>e),getDrapeSourceRenderer:e=>this._renderers.get(e)}}};m([b()],Te.prototype,"hasHighlights",void 0),m([b()],Te.prototype,"_sortedDrapeSourceRenderersDirty",void 0),m([b()],Te.prototype,"_shaderTechniques",void 0),m([b({constructOnly:!0})],Te.prototype,"view",void 0),m([b()],Te.prototype,"worldToPCSRatio",void 0),m([b()],Te.prototype,"spatialReference",void 0),m([b({type:Boolean,readOnly:!0})],Te.prototype,"updating",null),m([b()],Te.prototype,"isEmpty",null),m([b({readOnly:!0})],Te.prototype,"rendersOccludedDraped",null),Te=m([tr("esri.views.3d.terrain.OverlayRenderer")],Te);class yd{constructor(t,r,i){this.drapeSource=t,this.renderer=r,this.index=i}}const wd=[[1,.5,.5],[.5,.5,1]],Bu=-2,Xs=Oe.OccludeAndTransparent;class ku{constructor(t,r={}){this.geometry=t,this.screenToWorldRatio=1,this._transformation=W(),this._shaderTransformation=null,this._boundingSphere=null,this.id=Oi(),this.layerUid=r.layerUid,this.graphicUid=r.graphicUid,this.castShadow=r.castShadow??!1,r.objectShaderTransformation!=null&&this.objectShaderTransformationChanged(r.objectShaderTransformation)}get transformation(){return this._transformation}set transformation(t){it(this._transformation,t),this._boundingSphere=null}get boundingInfo(){return this.geometry.boundingInfo}objectShaderTransformationChanged(t){t==null?this._shaderTransformation=null:(this._shaderTransformation??(this._shaderTransformation=W()),Be(this._shaderTransformation,t,this.geometry.transformation)),this._boundingSphere=null}get boundingSphere(){return this.boundingInfo?(this._boundingSphere==null&&(this._boundingSphere??(this._boundingSphere=da()),ye(Mr(this._boundingSphere),this.boundingInfo.center,this.shaderTransformation),this._boundingSphere[3]=this.boundingInfo.radius*ga(this.shaderTransformation)),this._boundingSphere):pn}get material(){return this.geometry.material}get type(){return this.geometry.type}get shaderTransformation(){return this._shaderTransformation??this.transformation}get attributes(){return this.geometry.attributes}get highlights(){return this.geometry.highlights}get occludees(){return this.geometry.occludees}get visible(){return this.geometry.visible}set visible(t){this.geometry.visible=t}}export{I as $,Su as A,Tu as B,Kt as C,Th as D,Fr as E,$a as F,xe as G,Fc as H,Pe as I,mh as J,vi as K,Lr as L,ba as M,ac as N,kl as O,Pc as P,Qa as Q,jl as R,_d as S,$l as T,Wl as U,$h as V,wh as W,xh as X,yh as Y,Sh as Z,kc as _,pc as a,Gh as a0,xi as a1,jh as a2,Lh as a3,Fh as a4,Gl as a5,Nh as a6,Ea as a7,ot as a8,at as a9,hd as aA,ad as aB,Xs as aC,Rs as aD,vu as aE,As as aF,cu as aG,rc as aH,We as aI,tu as aJ,iu as aK,au as aL,Ri as aM,Ws as aN,Zc as aO,$u as aP,id as aQ,Or as aR,Ti as aS,ka as aT,Za as aU,mc as aV,Ou as aW,Cu as aX,nc as aY,dc as aZ,ed as a_,fc as aa,Ic as ab,Qt as ac,ja as ad,Ru as ae,ee as af,sd as ag,ws as ah,nu as ai,tc as aj,rl as ak,ul as al,Ir as am,vl as an,G as ao,rt as ap,Dl as aq,hh as ar,z as as,Te as at,Si as au,Os as av,At as aw,du as ax,Y as ay,Ts as az,Ci as b,Pr as c,Rh as d,Zt as e,be as f,Dh as g,Hh as h,Uh as i,xa as j,Vh as k,Ph as l,ku as m,er as n,Wh as o,$c as p,Eh as q,il as r,Ch as s,Bu as t,Ih as u,bh as v,Mh as w,Ah as x,Oh as y,El as z};
