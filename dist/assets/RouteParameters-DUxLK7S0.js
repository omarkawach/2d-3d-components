import{o as t,y as r,bC as p,X as w,bg as g,aV as f,ei as m,s as I,U as b,l5 as $,aH as Q,P as X,dZ as U,jQ as Y,a8 as _,ad as G,bh as tt,T as et,ak as rt}from"./index-8ERthB3p.js";import{n as M,f as ot}from"./utils-1zmckiYC.js";import{U as h,y as k,a as it,R as st,b as F,j as L,w as nt,S as at,D as C,c as lt,k as pt,d as ut,o as dt,l as ct}from"./Stop-CReeEpiF.js";import{t as yt}from"./commonProperties-DHiB1uzW.js";let u=class extends g{constructor(i){super(i),this.dataType=null,this.name=null,this.parameterNames=null,this.restrictionUsageParameterName=null,this.timeNeutralAttributeName=null,this.trafficSupport=null,this.units=null,this.usageType=null}};t([r({type:String})],u.prototype,"dataType",void 0),t([p(h,{ignoreUnknown:!1})],u.prototype,"name",void 0),t([r({type:[String]})],u.prototype,"parameterNames",void 0),t([r({type:String})],u.prototype,"restrictionUsageParameterName",void 0),t([p(k,{ignoreUnknown:!1})],u.prototype,"timeNeutralAttributeName",void 0),t([r({type:String})],u.prototype,"trafficSupport",void 0),t([p(it)],u.prototype,"units",void 0),t([p(st)],u.prototype,"usageType",void 0),u=t([w("esri.rest.support.NetworkAttribute")],u);const mt=u;let v=class extends g{constructor(i){super(i),this.buildTime=null,this.name=null,this.networkAttributes=null,this.networkSources=null,this.state=null}};t([r({type:Number})],v.prototype,"buildTime",void 0),t([r({type:String})],v.prototype,"name",void 0),t([r({type:[mt]})],v.prototype,"networkAttributes",void 0),t([r()],v.prototype,"networkSources",void 0),t([r({type:String})],v.prototype,"state",void 0),v=t([w("esri.rest.support.NetworkDataset")],v);const vt=v;let l=class extends g{constructor(i){super(i),this.accumulateAttributeNames=null,this.attributeParameterValues=null,this.currentVersion=null,this.defaultTravelMode=null,this.directionsLanguage=null,this.directionsLengthUnits=null,this.directionsSupportedLanguages=null,this.directionsTimeAttribute=null,this.hasZ=null,this.impedance=null,this.networkDataset=null,this.supportedTravelModes=null}readAccumulateAttributes(i){return i==null?null:i.map(s=>h.fromJSON(s))}writeAccumulateAttributes(i,s,n){i!=null&&i.length&&(s[n]=i.map(a=>h.toJSON(a)))}get capabilities(){return{supportsNow:(this.currentVersion??10)>=10.81}}readDefaultTravelMode(i,s){var a,y;const n=((a=s.supportedTravelModes)==null?void 0:a.find(({id:c})=>c===s.defaultTravelMode))??((y=s.supportedTravelModes)==null?void 0:y.find(({itemId:c})=>c===s.defaultTravelMode));return n?L.fromJSON(n):null}};t([r()],l.prototype,"accumulateAttributeNames",void 0),t([f("accumulateAttributeNames")],l.prototype,"readAccumulateAttributes",null),t([m("accumulateAttributeNames")],l.prototype,"writeAccumulateAttributes",null),t([r()],l.prototype,"attributeParameterValues",void 0),t([r()],l.prototype,"capabilities",null),t([r()],l.prototype,"currentVersion",void 0),t([r()],l.prototype,"defaultTravelMode",void 0),t([f("defaultTravelMode",["defaultTravelMode","supportedTravelModes"])],l.prototype,"readDefaultTravelMode",null),t([r()],l.prototype,"directionsLanguage",void 0),t([p(F)],l.prototype,"directionsLengthUnits",void 0),t([r()],l.prototype,"directionsSupportedLanguages",void 0),t([p(k,{ignoreUnknown:!1})],l.prototype,"directionsTimeAttribute",void 0),t([r()],l.prototype,"hasZ",void 0),t([p(h,{ignoreUnknown:!1})],l.prototype,"impedance",void 0),t([r({type:vt})],l.prototype,"networkDataset",void 0),t([r({type:[L]})],l.prototype,"supportedTravelModes",void 0),l=t([w("esri.rest.support.NetworkServiceDescription")],l);const ht=l,wt=()=>X.getLogger("esri.rest.networkService");function Jt(e,i,s,n){n[s]=[i.length,i.length+e.length],e.forEach(a=>{i.push(a.geometry)})}function Dt(e,i){for(let s=0;s<i.length;s++){const n=e[i[s]];if(n&&n.length)for(const a of n)a.z=void 0}wt().warnOnce(`The remote Network Analysis service is powered by a network dataset which is not Z-aware.
Z-coordinates of the input geometry are ignored.`)}function Et(e,i){for(let s=0;s<i.length;s++){const n=e[i[s]];if(n&&n.length){for(const a of n)if(a!=null&&a.hasZ)return!0}}return!1}async function Vt(e,i,s){if(!e)throw new I("network-service:missing-url","Url to Network service is missing");const n=M({f:"json",token:i},s),{data:a}=await b(e,n),y=a.currentVersion>=10.4?gt(e,i,s):ft(e,s),{defaultTravelMode:c,supportedTravelModes:N}=await y;return a.defaultTravelMode=c,a.supportedTravelModes=N,ht.fromJSON(a)}async function ft(e,i){var E,V,Z;const s=M({f:"json"},i),{data:n}=await b(e.replace(/\/rest\/.*$/i,"/info"),s);if(!(n!=null&&n.owningSystemUrl))return{supportedTravelModes:[],defaultTravelMode:null};const{owningSystemUrl:a}=n,y=$(a)+"/sharing/rest/portals/self",{data:c}=await b(y,s),N=Q("helperServices.routingUtilities.url",c);if(!N)return{supportedTravelModes:[],defaultTravelMode:null};const R=ot(a),W=/\/solve$/i.test(R.path)?"Route":/\/solveclosestfacility$/i.test(R.path)?"ClosestFacility":"ServiceAreas",q=M({f:"json",serviceName:W},i),H=$(N)+"/GetTravelModes/execute",A=await b(H,q),J=[];let D=null;if((V=(E=A==null?void 0:A.data)==null?void 0:E.results)!=null&&V.length){const K=A.data.results;for(const T of K)if(T.paramName==="supportedTravelModes"){if((Z=T.value)!=null&&Z.features){for(const{attributes:x}of T.value.features)if(x){const z=JSON.parse(x.TravelMode);J.push(z)}}}else T.paramName==="defaultTravelMode"&&(D=T.value)}return{supportedTravelModes:J,defaultTravelMode:D}}async function gt(e,i,s){try{const n=M({f:"json",token:i},s),a=$(e)+"/retrieveTravelModes",{data:{supportedTravelModes:y,defaultTravelMode:c}}=await b(a,n);return{supportedTravelModes:y,defaultTravelMode:c}}catch(n){throw new I("network-service:retrieveTravelModes","Could not get to the NAServer's retrieveTravelModes.",{error:n})}}let d=class extends U(g){constructor(e){super(e),this.doNotLocateOnRestrictedElements=null,this.geometry=null,this.geometryType=null,this.name=null,this.spatialRelationship=null,this.type="layer",this.where=null}};t([r({type:Boolean,json:{write:!0}})],d.prototype,"doNotLocateOnRestrictedElements",void 0),t([r({types:Y,json:{read:_,write:!0}})],d.prototype,"geometry",void 0),t([p(nt)],d.prototype,"geometryType",void 0),t([r({type:String,json:{name:"layerName",write:!0}})],d.prototype,"name",void 0),t([p(at,{name:"spatialRel"})],d.prototype,"spatialRelationship",void 0),t([r({type:String,json:{write:!0}})],d.prototype,"type",void 0),t([r({type:String,json:{write:!0}})],d.prototype,"where",void 0),d=t([w("esri.rest.support.DataLayer")],d);const Tt=d;var O;let B=O=class extends G{constructor(e){super(e),this.doNotLocateOnRestrictedElements=null}clone(){return new O({doNotLocateOnRestrictedElements:this.doNotLocateOnRestrictedElements,...this.cloneProperties()})}};t([r({type:Boolean,json:{write:!0}})],B.prototype,"doNotLocateOnRestrictedElements",void 0),B=O=t([w("esri.rest.support.NetworkFeatureSet")],B);const St=B;let S=class extends U(g){constructor(e){super(e),this.doNotLocateOnRestrictedElements=null,this.url=null}};t([r({type:Boolean,json:{write:!0}})],S.prototype,"doNotLocateOnRestrictedElements",void 0),t([r({type:String,json:{write:!0}})],S.prototype,"url",void 0),S=t([w("esri.rest.support.NetworkUrl")],S);const bt=S;var P;let o=P=class extends U(g){constructor(e){super(e),this.accumulateAttributes=null,this.apiKey=null,this.attributeParameterValues=null,this.directionsLanguage=null,this.directionsLengthUnits=null,this.directionsOutputType=null,this.directionsStyleName=null,this.directionsTimeAttribute=null,this.findBestSequence=null,this.geometryPrecision=null,this.geometryPrecisionM=null,this.geometryPrecisionZ=null,this.ignoreInvalidLocations=null,this.impedanceAttribute=null,this.outputGeometryPrecision=null,this.outputGeometryPrecisionUnits=null,this.outputLines="true-shape",this.outSpatialReference=null,this.overrides=null,this.pointBarriers=null,this.polygonBarriers=null,this.polylineBarriers=null,this.preserveFirstStop=null,this.preserveLastStop=null,this.preserveObjectID=null,this.restrictionAttributes=null,this.restrictUTurns=null,this.returnBarriers=!1,this.returnDirections=!1,this.returnPolygonBarriers=!1,this.returnPolylineBarriers=!1,this.returnRoutes=!0,this.returnStops=!1,this.returnTraversedEdges=null,this.returnTraversedJunctions=null,this.returnTraversedTurns=null,this.returnZ=!0,this.startTime=null,this.startTimeIsUTC=!0,this.stops=null,this.timeWindowsAreUTC=null,this.travelMode=null,this.useHierarchy=null,this.useTimeWindows=null}static from(e){return tt(P,e)}readAccumulateAttributes(e){return e==null?null:e.map(i=>h.fromJSON(i))}writeAccumulateAttributes(e,i,s){e!=null&&e.length&&(i[s]=e.map(n=>h.toJSON(n)))}writePointBarriers(e,i,s){j(e,i,s)}writePolygonBarrier(e,i,s){j(e,i,s)}writePolylineBarrier(e,i,s){j(e,i,s)}readRestrictionAttributes(e){return e==null?null:e.map(i=>C.fromJSON(i))}writeRestrictionAttributes(e,i,s){e!=null&&e.length&&(i[s]=e.map(n=>C.toJSON(n)))}readStartTime(e,i){const{startTime:s}=i;return s==null?null:s==="now"?"now":new Date(s)}writeStartTime(e,i){e!=null&&(i.startTime=e==="now"?"now":e.getTime())}readStops(e,i){return Mt(i.stops)}writeStops(e,i,s){j(e,i,s)}};t([r({type:[String],json:{name:"accumulateAttributeNames",write:!0}})],o.prototype,"accumulateAttributes",void 0),t([f("accumulateAttributes")],o.prototype,"readAccumulateAttributes",null),t([m("accumulateAttributes")],o.prototype,"writeAccumulateAttributes",null),t([r(yt)],o.prototype,"apiKey",void 0),t([r({json:{write:!0}})],o.prototype,"attributeParameterValues",void 0),t([r({type:String,json:{write:!0}})],o.prototype,"directionsLanguage",void 0),t([p(F)],o.prototype,"directionsLengthUnits",void 0),t([p(lt)],o.prototype,"directionsOutputType",void 0),t([p(pt)],o.prototype,"directionsStyleName",void 0),t([p(k,{name:"directionsTimeAttributeName",ignoreUnknown:!1})],o.prototype,"directionsTimeAttribute",void 0),t([r({type:Boolean,json:{write:!0}})],o.prototype,"findBestSequence",void 0),t([r({type:Number,json:{write:!0}})],o.prototype,"geometryPrecision",void 0),t([r({type:Number,json:{write:!0}})],o.prototype,"geometryPrecisionM",void 0),t([r({type:Number,json:{write:!0}})],o.prototype,"geometryPrecisionZ",void 0),t([r({type:Boolean,json:{write:!0}})],o.prototype,"ignoreInvalidLocations",void 0),t([p(h,{name:"impedanceAttributeName",ignoreUnknown:!1})],o.prototype,"impedanceAttribute",void 0),t([r({type:Number,json:{write:!0}})],o.prototype,"outputGeometryPrecision",void 0),t([p(ut)],o.prototype,"outputGeometryPrecisionUnits",void 0),t([p(dt)],o.prototype,"outputLines",void 0),t([r({type:et,json:{name:"outSR",write:!0}})],o.prototype,"outSpatialReference",void 0),t([r({json:{write:!0}})],o.prototype,"overrides",void 0),t([r({json:{name:"barriers",write:!0}})],o.prototype,"pointBarriers",void 0),t([m("pointBarriers")],o.prototype,"writePointBarriers",null),t([r({json:{write:!0}})],o.prototype,"polygonBarriers",void 0),t([m("polygonBarriers")],o.prototype,"writePolygonBarrier",null),t([r({json:{write:!0}})],o.prototype,"polylineBarriers",void 0),t([m("polylineBarriers")],o.prototype,"writePolylineBarrier",null),t([r({type:Boolean,json:{write:!0}})],o.prototype,"preserveFirstStop",void 0),t([r({type:Boolean,json:{write:!0}})],o.prototype,"preserveLastStop",void 0),t([r({type:Boolean,json:{write:!0}})],o.prototype,"preserveObjectID",void 0),t([r({type:[String],json:{name:"restrictionAttributeNames",write:!0}})],o.prototype,"restrictionAttributes",void 0),t([f("restrictionAttributes")],o.prototype,"readRestrictionAttributes",null),t([m("restrictionAttributes")],o.prototype,"writeRestrictionAttributes",null),t([p(ct)],o.prototype,"restrictUTurns",void 0),t([r({type:Boolean,json:{write:!0}})],o.prototype,"returnBarriers",void 0),t([r({type:Boolean,json:{write:!0}})],o.prototype,"returnDirections",void 0),t([r({type:Boolean,json:{write:!0}})],o.prototype,"returnPolygonBarriers",void 0),t([r({type:Boolean,json:{write:!0}})],o.prototype,"returnPolylineBarriers",void 0),t([r({type:Boolean,json:{write:!0}})],o.prototype,"returnRoutes",void 0),t([r({type:Boolean,json:{write:!0}})],o.prototype,"returnStops",void 0),t([r({type:Boolean,json:{write:!0}})],o.prototype,"returnTraversedEdges",void 0),t([r({type:Boolean,json:{write:!0}})],o.prototype,"returnTraversedJunctions",void 0),t([r({type:Boolean,json:{write:!0}})],o.prototype,"returnTraversedTurns",void 0),t([r({type:Boolean,json:{write:!0}})],o.prototype,"returnZ",void 0),t([r({json:{write:!0}})],o.prototype,"startTime",void 0),t([f("startTime")],o.prototype,"readStartTime",null),t([m("startTime")],o.prototype,"writeStartTime",null),t([r({type:Boolean,json:{write:!0}})],o.prototype,"startTimeIsUTC",void 0),t([r({json:{write:!0}})],o.prototype,"stops",void 0),t([f("stops")],o.prototype,"readStops",null),t([m("stops")],o.prototype,"writeStops",null),t([r({type:Boolean,json:{write:!0}})],o.prototype,"timeWindowsAreUTC",void 0),t([r({type:L,json:{write:!0}})],o.prototype,"travelMode",void 0),t([r({type:Boolean,json:{write:!0}})],o.prototype,"useHierarchy",void 0),t([r({type:Boolean,json:{write:!0}})],o.prototype,"useTimeWindows",void 0),o=P=t([w("esri.rest.support.RouteParameters")],o);const Zt=o;function Nt(e){return e&&"type"in e}function At(e){return e&&"features"in e&&"doNotLocateOnRestrictedElements"in e}function jt(e){return e&&"url"in e}function Bt(e){return e&&"features"in e}function Mt(e){return Nt(e)?Tt.fromJSON(e):jt(e)?bt.fromJSON(e):At(e)?St.fromJSON(e):Bt(e)?G.fromJSON(e):null}function j(e,i,s){e!=null&&(i[s]=rt.isCollection(e)?{features:e.toArray().map(n=>n.toJSON())}:e.toJSON())}export{Zt as O,Et as c,Vt as d,Dt as f,Jt as u};
